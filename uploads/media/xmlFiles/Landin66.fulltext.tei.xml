<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/doyougnu/tmp/grobid-grobid-parent-0.4.4/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-11-01T17:54+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Next 700 Programming Languages</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Landin</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Univac Division of Sperry Rand Corp</orgName>
								<address>
									<settlement>New York</settlement>
									<region>New York</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Next 700 Programming Languages</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Most programming languages are partly a way of expressing things in terms of other things and partly a basic set of given things. The Isw~M (If you See What I Mean) system is a byproduct of an attempt to disentangle these two aspects in some current languages.</p><p>This attempt has led the author to think that many linguistic idiosyneracies are concerned with the former rather than the latter, whereas aptitude for a particular class of tasks is essentially determined by the latter rather than the former. The conclusion follows that many language characteristics are irrelevant to the alleged problem orientation.</p><p>IswI~ is an attempt at a general purpose system for describing things in terms of other things, that can be problem-oriented by appropriate choice of "primitives." So it is not a language so much as a family of languages, of which each member is the result of choosing a set of primitives. The possibilities concerning this set and what is needed to specify such a set are discussed below.</p><p>Isw~M is not alone in being a family, even after mere syntactic variations have been discounted (see Section 4). In practice, this is true of most languages that achieve more than one implementation, and if the dialects are well disciplined, they might with luck be characterized as Presented at an ACM Programming Languages and Pragmatics Conference, San Dimes, California, August 1965.</p><p>1 Throe is no more use or mentiol~ of X in this paper--eognoseenti will nevertheless sense an undercurrent. A not inappropriate title would have been "Church without lambda," differences in the set of things provided by the library or operating system. Perhaps had ALGOL 60 been launched as a family instead of proclaimed as a language, it would have fielded some of the less relevant criticisms of its deficiencies.</p><p>At first sight the facilities provided in IswI~,~ will appear comparatively meager. This appearance will be especially misleading to someone who has not appreciated how much of current manuals are devoted to the explanation of common (i.e., problem-orientation independent) logical structure rather than problem-oriented specialties. For example, in almost every language a user can coin names, obeying certain rules about the contexts in which the name is used and their relation to the textual segments that introduce, define, declare, or otherwise constrain its use. These rules vary considerably from one language to another, and frequently even within a single language there may be different conventions for different classes of names, with near-analogies that come irritatingly close to being exact. (Note that restrictions on what names can be coined also vary, but these are trivial differences. When they have any logical significance it is likely to be perni- cious, by leading to puns such as ALaOL'S integer labels.) So rules about user-coined names is an area in which we might expect to see the history of computer applica- tions give ground to their logic. Another such area is in specifying functional relations. In fact these two areas are closely related since any use of a user-coined name im- plicitly involves a functional relation; e.g., compare ISW~M is thus part. programming language and part pro- gram for research. A possible first step in the research program is 1700 doctoral theses called "A Correspondence between x and Church's X-notation. ''~</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The where-Notation</head><p>In ordinary mathematical communication, these uses of 'where' require no explanation. Nor do the following: A phrase of the form 'where definition' will be called a "where-clause." An expression of the form 'expression where-clause' is a "where-expression." Its two principal components are called, respectively, its "main clause" and its "supporting definition." To put 'where' into a programming language the following questions need answers.</p><p>Linguistic Structure. What structures of expression can appropriately be qualified by a where-clause, e.g., conditional expressions, operand-listings, statements, declarations, where-expressions?</p><p>Likewise, what structures of expression can appro- priately be written as the right-hand side (rhs) of a supporting definition? What contexts are appropriate for a where-expression, e.g., as an arm of a conditional ex- pression, an operator, the main-clause of a where-ex- pression, the left-hand side (lhs) of a supporting definition, the rhs of a supporting definition?</p><p>Syntax. Having answered the above questions, what are the rules for writing the acceptable configurations unambiguously? E.g., where are brackets optional or obligatory? or other punctuation? or line breaks? or in- dentation? Note the separation of decisions about struc- ture from decisions about syntax. (This is not a denial that language designers might iterate, like hardware designers who distinguish levels of hardware design.)</p><p>Semantic Constraints on Linguistic Structure. In the above examples each main clause was a numerical ex- pression; i.e., given appropriate meanings for the various identifiers in it, it denoted a number. What other kinds of meaning are appropriate for a mainclause, e.g., arrays, functions, structure descriptions, print-formats?</p><p>Likewise what kinds of meaning are appropriate for rhs's of supporting definitions? Notice there is not a third question analogous to the third question above under linguistic structure. This is because a where-expression must mean the same kind of thing as its main clause and hence raises no new question concerning what contexts are meaningful. Notice also that the questions about meaning are almost entirely independent of those about structure. They depend on classifying expressions in two ways that run across each other.</p><p>Outcome. What is the outcome of the more recondite structural configurations among those deemed admissible, e.g. mixed nests of where-expressions, function definitions, conditional expressions, etc.?</p><p>Experimental programming has led the author to think that there is no configuration, however unpromising it might seem when judged cold, that will not turn up quite naturally. Furthermore, some configurations of 'where' that might first appear to reflect somewhat pedantic dis- tinctions, in fact provide close matches for current lan- guage features such as name/value and own (see <ref type="bibr">[2,</ref><ref type="bibr">3]</ref>).</p><p>All these questions are not answered in this paper. The techniques for answering them are outlined in Section 4.</p><p>One other issue arises when 'where' is added to a programming language--types and specifications. A method of expressing these functionally is explained in <ref type="bibr">[2]</ref>. It amounts to using named transfer-functions instead of class names like integer, i.e., writing where n = round(n) instead of the specification integer n Thus the use of functional notation does not jeopardize the determination of type from textual evidence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Physical ISWIM and :Logical ISWIM</head><p>Like ALGOL 60, ISWIM has no prescribed physical appearance. ALGOL C0'S designers sought to avoid commit- ment to any particular sets of characters or type faces. Accordingly they distinguish between "publication hm- guage," "reference language" and "hardware languages." Of these the reference language was the standard and was used in the report itself whenever pieces of ALGOL 60 occurred. Publication and hardware languages are trans- literations of the reference language, varying according to the individual taste, needs and physical constraints on available type faces and characters.</p><p>Such variations are different physical representations of a single abstraction, whose most faithful physical representation is the reference language. In describing IswI~ we distinguish an abstract language called "logical ISWIM," whose texts are made up of "textual elements," characterized without commitment to a particular physical representation. There is a physical representation suitable for the medium of this report, and used for presenting each piece of IswI~1 that occurs in this report. So this physical representation corresponds to "reference ALGOL 60," and is called "reference ISWIM," or the "IswI~i reference representation," or the "IswI~,r reference hm- guage."</p><p>To avoid imprecision one should never speak just of "ISWIM," but always of "logical IswxM" or of "such- and-such physical ISWlM." However, in loose speech, where the precise intention is clear or unimportant, we refer to "ISWlM" without quMifieation. We aim at a more formal relation between physical and logical languages than was the case in the ALGOL C0. This is necessary since we wish to systematize and mechanize the use of different physical representations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Four Levels of Abstraction</head><p>The "physical~logical" terminology is often used to distinguish features that are a fortuitous consequence of physical conditions from features that are in some sense more essential. This idea is carried further by making a similar distinction among the "more essential" features. In fact ISWlM is presented here as a four-level concept comprising the following:</p><p>(1) physical IswlM'S, of which one is the reference language and others are various publication and hardware languages (not described here).</p><p>(2) logical ISWlM, which is uncommitted as to char- acter sets and type faces, but committed as to the sequence of textual elements, and the grammatical rules for group- ing them, e.g., by parentheses, indentation and precedence relations.</p><p>(3) abstract Iswls,,, which is uncommitted as to the grammatical rules of sequence and grouping, but com- mitted as to the grammatical categories and their nesting structure. Thus abstract Iswis,~ is a "tree language" of which logical IswlM is one linearization.</p><p>(4) applicative expressions (AEs), which constitute another tree language, structurally more austere than abstract ISWlM, and providing certain basic grammatical categories in terms of which all of Isw1~'s more numerous categories can be expressed.</p><p>The set of acceptable texts of :t physical ISWlM is specified by the relations between 1 and 2, and between 2 and 3. The outcome of each text is specified by these relations, together with a "frame of reference," i.e., a rule that associates a meaning with each of a chosen set of identifiers.</p><p>These are the things that vary from one member of our language family to the next. The specification of the family is completed by the relation between abstract IswI~ and AEs, together with an abstract machine that interpret AEs. These elements are the same for all members of the family and are not discussed in this paper (see <ref type="bibr">[1,</ref><ref type="bibr">2,</ref><ref type="bibr">4]</ref>).</p><p>The relationship between physical ISWlM and logical ISWIM is fixed by saying what physical texts represent each logical element, and also what layout is permitted in stringing them together. The relationship between logical I s w ~ and abstract IswlM is fixed by a formal grammar not unlike the one in the ALGOL 60 report, together with a statement connecting the phrase categories with the abstract grammatical categories.</p><p>These two relations cover what is usually called the "syntax" or "grammar" of a language. In this paper syntax is not discussed beyond a few general remarks and a few examples whose meaning should be obvious.</p><p>The relationship between abstract Iswls( and AEs is fixed by giving the form of AE equivalent to each abstract IswiM grammatical category. It happens that these latter include a subset that exactly matches AEs. Hence this link in our chain of reh~tions is roughly a mapping of ISWIM into an essential "kernel" of IswIM, of which all the rest is mere decoration.  The only obscure coinage is " b e e t , " which a b b r e v i a t e s " b e t a - redex," i.e., " a n expression amenable to rule (fl)"; see Section 7'. demand, simple, infixed, etc; also the selectors body, rator, leflarm, nee, etc; also (taking for granted certain un- formalized conventions concerning structure definitions) the constructors, consdemand, conscombination <ref type="bibr">(</ref>  [x=a+2b a definee (nee), which is an abe, and a definiens (niens), which is an aexp, or functionform, arid has</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">A b s t r a c t I S W I M</head><formula xml:id="formula_0">[f(x) = z ( x + l ) a lefthandside (lhs),</formula><p>which is an abe-list of length &gt;2, and a righthandside (rhs), which is an aexp or programpoint, and has</p><formula xml:id="formula_1">[ p p f ( x ) = x ( x + l )</formula><p>a body which is an adef, or circular, and has [tee f ( n ) = ( n = 0 ) -+ l ; n f ( n -1 ) a body which is an adef, or simultaneous, and has [x=a+2b a n d y=2a--b a body, which is an adef-list, or beet, and has</p><formula xml:id="formula_2">[f(y) = z ( x + y ) a mainclause, w h e r e x=a+2b</formula><p>which is a n adef, and a support, which is an adef.</p><p>w h e r e an a b e is either simple, and has body, which is an identifier, or else, is an abv-lislo.</p><p>[x, (y, z), w A program-point definition introduces a deviant kind of function. Applying such a function precipitates pre- mature termination of the where-expression containing it, and causes its result to be delivered as the value of the entire where-expression.</p><p>Program-points are Iswli'S, nearest thing to jumping. Assignment is covered as a particular case of an operator. For both of these the precise specification is in terms of the underlying abstract machine (see <ref type="bibr">[2]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Relationship to LISP</head><p>IswI~r can be looked on as an attempt to deliver LisP fronI its eponymous commitment to lists, its reputation for hand-to-mouth storage allocation, the hardware dependent flavor of its pedagogy, its heavy bracketing, and its compromises with tradition. These five points are now dealt with in turn:</p><p>(1) Iswi~ has no particular problem orientation. Experiments so far have been mainly in numerical work and language processing with brief excursions into "com- mercial" programming and elsewhere. No bias towards or away from a particular field of application has emerged.</p><p>(2) Outside a certain subset (corresponding closely to ALGOL ~0 without dynamic own arrays), IswIM needs garbage collection. An experimental prototype imple- mentation followed common ALGOL 60 practice. It used dynamic storage allocation with two sources, one LIFO and the other garbage collected, with the intention that the LIFO source should take as big a share as possible.</p><p>However, as with ALGOL 60, there is a latent potential for prealloeating storage in certain favorable and com- monly useful situations. Compared with LISP the chief amelioration of storage allocation comes out of a mere syntactic difference, namely, the use of where (ol 'let' which is exactly equal in power and program structure). This provides a block-structure not dissimilar in textual appearance from ALGOL 60'S, though it slips off the pen more easily, and is in many respects more generM.</p><p>(3) LisP has some dark corners, especially outside "pure LISP," in which both teachers and programmers resort to talking about addresses and to drawing storage diagrams. The abstract machine underlying IswI~,r is aimed at illuminating these corners with a mininmm of hardware dependence.</p><p>(4) The textual appearance of IswI~l is not like Lisp's S-expressions. It is nearer to LISP'S M-expressions (which constitute an informal language used as an intermediate result in hand-preparing LISP programs). IswlAi has the following additional features: (a) "Auxiliary" definitions, indicated by 'let' or 'where', with two decorations: 'and' for simultaneous definitions, and 'rec' for self-referential definitions (not to be mistaken for a warning about recursive activation, which can of course also arise from self-application, and without self- reference).</p><p>(b) Infixed operators, incorporated systematically. A logical ISWIM can be defined in terms of four unspecified parameters: three subsets of the class of identifiers, for use as prefixed, infixed and postfixed operators; and a prec- edence relation defined over the union of these subsets.</p><p>(c) Indentation, used to indicate program structure. A physical IswiM can be defined in terms of an unspecified parameter: a subset of phrase categories, instances of which are restricted in layout by the following rule called "the offside rule." The southeast quadrant that just con- tains the phrase's first symbol nmst contain the entire phrase, except possibly for bracketed subsegments. This rule has three important features. It is based on vertical alignment, not character width, and hence is equally appropriate in handwritten, typeset or typed texts. Its use is not obligatory, and use of it can be mixed freely with more conventionM alternatives like punctuation. Also, it is incorporated in IswI~t in a systematic way that admits of alternatives without changing other features of Isw~.r and that can be applied to other languages.</p><p>(5) The most important contribution of LisP was not in listprocessing or storage allocation or in notation, but in the logic~d properties lying behind the notation, ttere Iswi?i makes little improvement because, except for a few minor details, Lisp left none to make. There are two equivalent ways of stating these properties.</p><p>(a) LIsP simplified the equivalence relations that determine the extent to which pieces of program can be interchanged without affecting the outcome.</p><p>(b) LISP brought the class of entities that are denoted by expressions a programmer can write nearer to those that arise in models of physical systems and in mathe- matieM and logical systems.</p><p>These remarks are expanded in Sections 7 and 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">The Characteristic Equivalences of ISWIM</head><p>For most programming languages there are certain statements of the kind, "There is a systematic equivalence between pieces of program like this, and pieces like that," that nearly hold but not quite. For instance in ALGOL 60 there is a nearly true such statement concerning procedure calls and blocks.</p><p>At first sight it might appear pedantic to quibble about such untidiness--"What's the point of having two different ways of doing the same thing anyway? Isn't it better to have two facilities than just one?" The author believes that expressive power should be by design rather than accident, and that there is great point in equivalences that hold without exception. It is a platitude that any given outcome can be achieved by a wide variety of programs. The practicability of all kinds of program-processing (optimizing, checking satisfaction of given conditions, constructing a program satisfying given conditions) depends on there being elegant equivalence rules. For IswlM there are four groups 3, concerning:</p><p>(1) the extent to which a subexpression can be replaced by an equivalent subexpression without disturbing the equivalence class of the whole expression. Without this group the other rules would be applicable only to complete expressions, not to subexpressions.</p><p>(2) user-coined names, i.e., in definitions and, in particu- lar, function definitions.</p><p>(3) built-in entities implicit in special forms of ex- pression. The only iiistanees of this in Iswllv[ are conditional expressions, listings and self-referential definitions.</p><p>(4) named entities added in any specific problem- orientation of IswIM.</p><p>3 To facilitate subsequent discussion each rule is preceded by a name, e.g., "(~t)", "(,)", etc. These are chosen to conform with precedents in Curry's Combinatory Logic.</p><formula xml:id="formula_3">GROUP 1 (tz) If L -= L' then L (M) -= L' (M) @) If M ~ M' then L (M) ~L (M') @') If M ~ M' then (L,...,M, ..-,N)~(L, ...,M', ...N) (v") If L ~ L' then (L--~M; N) ~ (L'--+M, N) (v') If M ~ M' then (L--aM; N) ~ (L-aM'; N) (vi~) If N -~ N' then (L--~M; N) ~ (L--~M; N') (v ~) If M -= M ~ then (L where x=M) ~-(Lwherex=M t)</formula><p>The significant omissions here are the main-clause in the last case above, the rhs of a function definition "f(x) = M" and of a circular definition "ree :c = M".</p><p>GRoue 2</p><formula xml:id="formula_4">(let) letx = M; L --= Lwherex = M (I') f(x) = L ~ f = (g where g(x)=L) f(a,b,c)(x,y) = L ~ f(a,b,c)= (gwhereg(x,y)=L)</formula><p>and so on for each shape of left-hand side Rules (I'), (~'), (D'), together with (Y) below, enable any definition to be "standardized," i.e., expressed in a lhs/rhs form, in which the lhs is precisely the definee. Thus a nonstandard definition can be transformed so as to be amenable to rules (~) and (~) (see Group 2'). Here 'x' may be any list-structure of distinct identifiers, provided that 'M' has structure that fits it. This rule is the most important, but it has only limited validity, namely, within the "purely functional" subset of ISWlM that results from not using the program-point feature or assignment.</p><formula xml:id="formula_5">(I) (f where f(x)=L) M ~ L wherex = M (~') (x=L)</formula><p>Its importance lies in a variant of a famous theorem of mathematical logic, the Church-Rosser theorem. This concerns the possibility of eliminating 'where' from an expression by repeatedly applying the rules stated above, including crucially (~). The theorem ensures that if there are several ways of doing this they all reach the same result.</p><p>The author thinks that the fruitful development to encompass all ISWlM will depend on establishing "safe" areas of an ISWlA~ expression, in which imperative features can be disregarded. The usefulness of this development will depend on how successfully ISWlM'S nonimperative features supersede conventional programming.</p><formula xml:id="formula_6">GROUP 3 (--~) true --~ M; N ~ M (--/) false -~ M; N ~ N (---~") P ~ M ~ P ~ M; undefined (undefined) undefined ~ self apply (selfapply) where self apply (f) = f(f) (Y) recx = L ~ x = (Lwhere recx = L) (D") (x, -..,z) = M ~-(x, '",z) = null (tkw) hw, ..., h(t~-lw) where w = M (for k &gt; 2) (x, (u, v), z) = M =-(x, (u, v), z) = null (taw) h(w), (null (t2w ') --~ h(w'), h(t(w')) where w' = h(t(w))) h(t2w)</formula><p>where w = M arid so on for each shape of definee</p><formula xml:id="formula_7">(null) null (nullisl) -= true (null I) null (La, ..', Lk) ~ false where (x, "', z) = Lb "", Lk (k &gt; 2) (h) h(L b "", Lk) ~ x</formula><p>where (x, -.., z) = Lj, .-., Lit (k &gt; 2)</p><formula xml:id="formula_8">(t) t(L1, ..., L~) ~ y, ..., z</formula><p>where (x,y, -.-,z) = L1, "', Lk</p><formula xml:id="formula_9">(k _ 3) (t') t(t(Ll, L2)) =--nullist</formula><p>where (x, y) = L1, L2</p><p>The rules about listings may appear willfully indirect. The more natural transformations are those effected by applying, for example, (D I') then (~). But these would have suffered the same limited validity as (~). In their above slightly cautious formulation the validity of (DI'), etc. is unrestricted, and the more powerful equivalences that hold for nonimperative expressions arise entirely from (/3).</p><p>GRouP 4 A problem-orientation of IswI~r can be characterized by additional axioms. In the simplest case such an axiom is an IswiM definition. The resulting modification is called a "definitional extension" of the original system.</p><p>In more elaborate cases axioms may mutually constrain a group of identifiers; e.g. the following rule for equality among integers: (=) Suppose L and M are ISWIM written integers (i.e., strings of digits); then either one or the other of the following holds:</p><formula xml:id="formula_10">L = M ~-true L = M ~ false</formula><p>according as L and 114 differ at most in lefthand zeros, or not. Another example, presented even less formally, is the structure definition for abstract ISWlM.</p><p>Group 1 above makes no provision for substitutions within expressions that are qualified by a supporting definition or are used to define a function. However, such a substitution is legitimized as long as it does not involve the definees or variables, by encasing it within applications of rule (/3) and its inverse (with any other rules that might <ref type="bibr">Volume</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">/ Number 3 March, 1966</head><p>Communications of the ACM be needed to produce something that is amenable to (~), i.e., a beet with a standard definition). EquivMence rules can be used to prove things about the system. For example, the reader will readily verify that the equivalence of f (6) where reef(n) = (n=0) --~ 1; nf (n--l) and 6 (f(5) where reef (n) = (n=0) --~ 1; nf (n--l)) can be established with the following steps: in this sequence we omit the auxiliary applications of (~), etc. that are needed at Mmost every step to legitimize the substitution.</p><formula xml:id="formula_11">(I'), (Y), (f~), (Y),<label>(</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Application and Denotation</head><p>The commonplace expressions of arithmetic and algebra have a certain simplicity that most communications to computers lack. In particular, (a) each expression has a nesting subexpression structure, (b) each subexpression denotes something (usually a number, truth vMue or numerical function), (c) the thing an expression denotes, i.e., its "value", depends only on the values of its sub- expressions, not on other properties of them.</p><p>It is these properties, and crucially (c), that explains why such expressions are easier to construct and under- stand. Thus it is (c) that lies behind the evolutionary trend towards "bigger righthand sides" in place of strings of small, explicitly sequenced assignments and jumps. When faced with a new notation that borrows the func- tional appearance of everyday algebra, it is (c) that gives us a test for whether the notation is genuinely functional or merely masquerading.</p><p>The important feature of ISWIM's equivalence rules is chat they guarantee the same desirable properties to ISWlM'S nonimperative subset. We may equate "abstract object" with "equivalence class," and equate "denotes" with "is a member of." Then the properties (g) and (v) ensures anologies of (c) above. They state that the value of an operator/operand combination depends only on the values of its component subexpressions, not on any other aspects of them.</p><p>Thus conditions (g) and (v) are equivalent to the existence of a dyadic operation among the abstract ob- jects; we call this operation "application."</p><p>The terminology of "abstract objects," "denoting" and "application" is frequently more convenient than that of equivalence relations. For example, it suggests another way of characterizing each problem-orientation of ISWlM. We can think of a set of abstract objects with a partially defined dyadic "application" operation and a monadic "designation" operation that associates a "primitive" abstract object with each of some chosen set of names, called the "constants" of the special system.</p><p>Consider for example a programming language that contains expressions such as 'wine' Anyone with a generous ontology will admit that this 6-character expression denotes the 4-character-string wine For such a person its use in the language is characterized by • the objects that it is applicable to, and the object it produces in each case (e.g., strings might be used like vectors, whose application to an integer produces an item of the string).</p><p>• The objects that it is amenable to, and the object it yields in each case (e.g., prefixing, appending, selection, etc.).</p><p>The sceptic need not feel left out. He just has to talk, a bit more clumsily, about Then he goes on to speak of the equivalence class of expressions that can serve as operand or operator to any of the above, and the equivalence class of the resulting operator/operand combination.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Note on Terminology</head><p>ISWIM brings into sharp relief some of the distinctions that the author thinks are intended by such adjectives as procedural, nonproeedural, algorithmic, heuristic, impera- tive, declarative, functional, descriptive. Here is a sug- gested classification, and one new word.</p><p>First, none of these distinctions are concerned with the use of pidgin English rather than pidgin algebra. Any pidgin algebra can be dressed up as pidgin English to please the generals. Conversely, it is a special ease of the thesis underlying ISWlM that any pidgin English that has so far been implemented can be stripped to pidgin algebra. There is nevertheless an important possibility of having languages that are heuristic on account of their "applica- tive structure" being heuristic.</p><p>An important distinction is the one between indicating what behavior, step-by-step, you want the machine to perform, and merely indicating what outcome you want. Put that way, the distinction will not stand up to close investigation. I suggest that the conditions (a-e) in Section 8 are a necessary part of "merely indicating what outcome you want." The word "denotative" seems more appro- priate than nonproeedural, declarative or functional. The antithesis of denotative is "imperative." Effectively "denotative" means "can be mapped into ISW~M without using jumping or assignment," given appropriate primi- tives.</p><p>It follows that functional programming has little to do with functional notation. It is a trivial and pointless task to rearrange some piece of symbolism into prefixed opera- tors and heavy bracketing. It is an intellectually demand- ing activity to characterize some physical or logical system as a set of entities and functional relations among them. However, it may be less demanding and more revealing than characterizing the system by a conventional program, and it may serve the same purpose. Having formulated the model, a specific desired feature of the system can be systematically expressed in functional notation. Eut other notations may be better human engineering. So the role of functional notation is a standard by which to describe others, and a standby when they fail.</p><p>The phrase "describe in terms of" has been used above with reference to algorithmic modes of expression, i.e., interchangeably with "express in terms of." In this sense "3 + 4" is a description of the number 7 in terms of the numbers 3 and 4. This conflicts with current use of the phrase "descriptive languages," which appears to follow the logicians. For example, a language is descriptive in which the machine is told On the other hand it might reasonably exclude Print solepositivezeroof <ref type="bibr">(1, --1, --6)</ref> where solepositivezeroo] happens to be a library function.</p><p>The author therefore suggests that there is a useful distinction that can be made here concerning languages. Consider the function i, which operates on a class (or property) having a sole member (or instance), and trans- forms it into its sole member. We are interested in whether or not a language permits reference to i, with more or less restricted domain.</p><p>For example the above programs become:</p><p>More precisely, the distinction hinges on whether, when "applicative structure" is imputed to the language, it can be done without resorting to i, or to primitives in terms of which i can be defined.</p><p>This discussion of i reveals the possibility that primitives might be sensationally nonalgorithmie. So the algorithmic/ heuristic distinction cuts across the denotative/imperative Volume 9 / Number <ref type="bibr">3 / March, 1966</ref> (i.e., nonproeedural/procedural) distinction. On the other hand if limited forms of i can be algorithmized, they still deserve the term "descriptive." So this factor is also independent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Eliminating Explielt Sequenelng</head><p>Thm'e is a game sometimes played with ALGOL 60 programs--rewriting them so as to avoid using labels and go to statements. It is part of a more embracing game-- reducing the extent to which the program conveys its information by explicit sequencing. Roughly speaking this amounts to using fewer and larger statements. The game's significance lies in that it frequently produces a more "transparent" program--easier to understand, debug, modify and incorporate into a larger program.</p><p>The author does not argue the ease against explicit sequencing here. Instead he takes as point of departure the observation that the user of any programming language is frequently presented with a choice between using explicit sequencing or some alternative feature of the language. Furthermore languages vary greatly in the alternatives they offer. For example, our game is greatly facilitated by ALGOL 60'S conditional statements and conditional ex- pressions. So the question considered here is: What other such features are there? This question is considered be- cause, not surprisingly, it turns out that an emphasis on describing things in terms of other things leads to the same kind of requirements as an emphasis against explicit sequencing.</p><p>Though A~GO~ g0 is comparatively favorable to this activity, it shares with most other current languages certain deficiencies that severely limit how far the game can go. The author's experiments suggest that two of the most needed features are:</p><p>• Treat a listing of expressions as a special ease of the class of expressions, especially in the arms of a conditional expression, and in defining a function.</p><p>• Treat, argument lists as a special ease of lists. So a triadic function can have its arguments supplied by a conditional whose arms are 3-listings, or by application of a function that produces a 3-list. A similar situation arises when a 3-listing occurs as a definee. (Even LIsP trips up here, over lists of length one.)</p><p>To clarify their practical use, here are some of the steps by which many a conventional ALGOL e0 or PL/1 program can be transformed into an IswI~,r program that exploits IswIsl's nonimperative features.</p><p>(1) Rewrite the program so as to use two-dimensional layout and arrows to illuminate the explicit sequencing, i.e., as a flowchart with algebraic steps. Rearrange this to achieve the least confusing network of arrows.</p><p>(2) Apply the following changes repeatedly wherever they are applicable:</p><p>(a) Replace a string of independent assignments by one multiple assignment.</p><p>(b) Replace an assignment having purely local signifi- cance by a where-clause.</p><p>(e) Replace procedures by type-procedures (possibly with multiple type), and procedure statements by assign- ment statements.</p><p>(d) Replace conditional jumps by conditional state- ments having bigger arms.</p><p>(e) Replace a branch whose arms have assignees in common by an assignment with conditional right-hand side.</p><p>(f) Replace a join by two calls for a procedure. It should be observed that translating into ISWlM does not force such rearrangements; it merely facilitates them.</p><p>One interesting observation is that the most recalcitrant uses of explicit sequencing appear to be associated with success/failure situations and the action needed on failure. Section 2 discussed adding 'where' to a conventional programming language. Theory and experiment both support the opposite approach, that taken in Llsv, of adding imperative features to a basically nonimperative language. One big advantage is that the resulting language will have a nonimperative subset.</p><p>The special claim of ISWlM is that it grafts procedural notions onto a purely functional base without disturbing many of the desirable properties. The underlying ideas have been presented in <ref type="bibr">[2]</ref>. This paper can do no more than begin the task of explaining their practical significance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">Conclusion</head><p>The languages people use to communicate with com- puters differ in their intended aptitudes, towards either a particular application area, or a particular phase of com- puter use (high level programming, program assembly, job scheduling, etc). They also differ in physical appear- ance, and more important, in logical structure. The ques- tion arises, do the idiosyncracies reflect basic logical properties of the situations that are being catered for? Or are they accidents of history and personal background that may be obscuring fruitful developments? This question is clearly important if we are trying to predict or imq_uence language evolution.</p><p>To answer it we must think in terms, not of languages, but of families of languages. That is to say we must systematize their design so that a new language is a point chosen from a well-mapped space, rather than a laboriously devised construction.</p><p>To this end the above paper has marshalled three techniques of language design: abstract syntax, axiomatiza- tion, and an underlying abstract machine.</p><p>It is assumed that future calls on language development cannot be forstalled without gener~lizing the alternatives to explicit sequencing. The innovations of "program- points" and the "off-side rule" are directed at two of the problems (respectively in the areas of semantics and syntax) that must consequently be faced.</p><p>with this, but I believe that if it came about that this notation were used for very wide communication and also publication, you would regret it because of the kind of rearrangement of manu- scripts done in printing, for example. You very frequently run into the problem that you have a wide written line and then suddenly you go to the Communications of the ACM and radically, perhaps, you have to compress it. The printer will do this in any way he likes; he is used to having great freedom here and he will foui up your notation.</p><p>Landin: I have great experience with this. (Laughter) I think I am probably the only person who has run through three versions of the galley proofs for the Communications of the ACM. However, I think that next time I could do better, and I think it is worth looking into. At any rate, the principle that [ have described here is a good deal better than some that one might think of ; for example it does riot depend on details of character width, character by character--it is just as good handwritten as it is printed. Secondly, limiting the breadth of the page, I agree with you, needs more consideration. By the time I got through with the particular example I am talking about, by getting it printed, I had devised what I thought was a fairly reasonable method of communicating the principles that have been used in indentation.</p><p>Floyd: Another objection that 7[ think is quite serious to indentation is that while it works on the micro-scale--that is, one page is all right--when dealing with an extensive program, turning from one page to the next there is no obvious way of indicating how far indentation stretches because there is no printing at all to indicate how far you have indented. I would like you to keep that in mind.</p><p>Landin: Yes, I agree. In practice I deal with this by first making the page breaks in sensible places.</p><p>Floyd: That's all right as long as you don't have an indented region which is simply several pages long.</p><p>Landin: Well in that ease the way I did it was to cut down the number of carryover levels to about four or five from one page to another. You can at least make it simpler when you are hand- writing by putting some kind of symbols at the bottom of the page and top of the continuation.</p><p>Floyd: Even if you regard your indentation spaces as characters there still doesn't seem to be any way--in fact, I am fairly sure there is no way--of representing the indentation conventions within a phrase-structure grammar.</p><p>Landin: Yes, but some indentation conventions can be kept within phrase structure grammars by introducing two terminal symbols that are grammatically like parentheses, but are textually like typewriter keys for settling and clearing tabulation positions. More precisely, the textual representation of the second of these symbols can be explained as the following sequence of typewriter actions: 1) line-feed; 2) back-space as far as the right-most tab position that is still currently active; 3) clear tab position; and 4) do step 2 again.</p><p>While this fits some indentation conventions, the olle I propose is too permissive to be included. For my language I have written a formal grammar that is not phrase structure and includes one departure that meets this problem.</p><p>Leavenworth: I should like to raise the question of eliminating explicit jumps, I mean of using recursion as against interation.</p><p>Landin: It seems to me that there are rather a small number of functions which you could use if you were writing a Lisp program in the places where ordinary programs would use iterations, and that if you were to use these the processor might do as well as if you had written a loop. For example, iterate (m, f, x) might apply f, m times to x with the result f'~(x). This is the simplest kind of loop I know and the function iterate provides a purely functional notation for this rather simple kind of loop. If a lot of familiar types of loop can be represented by a few functions which could be defined recursively, I think it is sensible to take these as primitive. Another such function is while (p, f, x) which goes on applying f to x until the predicate p becomes false.</p><p>Strachey: I must just interpolate here something which is a bit of advertising l suppose. Nearly all the linguistic features, such as where and while and and and recursive, that Peter Landin has been talking about are incorporated as an integral part of a pro- gramming language being developed at Cambridge and London called CPL. In fact the where clauses are a very important feature of this" language.</p><p>Irons: I have put together a program which uses some of these features and which has a standard output which prints the pro- gram in an indented manner. If it runs off the right end of the page, it t:rnduces another page to go on the right, and so forth. While certainly there are some situations that occur when it would be a bit awkward to make the paper go around the room, I have found that in practice, by and large it is true that this is a very profit- able a ay of operating.</p><p>Strachey: I should like to intervene now and try to initiate a slightly more general discussion on declarative or descriptive languages and to try to clear up some points about which there is considerable confusion. I have called the objects I am trying to discuss DLs because I don't quite know what they are. Here are some questions concerning ])Ls: (1) What are DLs? (2) What is their relationship to imperative languages? (3) Why do we need DLs? (4) How can we use them to program? (5) How can we implement them? (6) How can we do this efficiently? (7) Should we mix l)Ls with imperative languages?</p><p>It seems to me that what I mean by DLs is not exactly what other people mean. I inean, roughly, languages which do not contain assignment statements or jumps. This is, as a matter of fact, not a very clear distinction because you can always disguise the assignments and the jumps, for that matter, inside other state- meat forms which m~ke them look different. The important characteristic of DLs is that it is possible to produce equivalence relations, particularly the rule for substitution which Peter Landin describes as (~) in his paper. That equivalance relation, which appears to be essential in ahnost every proof, does not hold if you allow assignment statements. The great advantage then of l)Ls is that they give you some hope of proving the equi- valence of program transformations and to begin to have a calculus for combining and manipulating them, which at the moment we haven't got.</p><p>I suggest that an answer to the second question is that DLs form a subset of all languages. They are an interesting subset, but one which is inconvenient to use unless you are used to it. We need them because at the moment we don't know how to construct proofs with languages which include imperatives and jumps.</p><p>How should we use them to program? I think this is a matter of learning a new programnling technique. I am not convinced that all problems are amenable to programming in DLs but I am not convinced that there are any which are not either; I preserve an open mind on this point. It is perfectly true that in the process of rewriting programs to avoid labels and jumps, you've gone half the way towards going into 1)Ls. When you have also avoided assignment statements, you've gone the rest of the way. With many problems yeu can, in fact, go the whole way. LisP has no assignment statements and it is remarkable what you can do with pure Lisp if you try. If you think of it in terms of the implementa- tions that we know about, the result is generally intolerably inefficient--but then that is where we come to the later questions.</p><p>How do we implement them? There have not been many at- tempts to implement DLs efficiently, I think. Obviously, it can be done fairly straightforwardly by an interpretive method, but this is very slow. Methods which compile a runable program run into a lot of very interesting problems. It can be done, because DLs are a subset of ordinary programming languages; any programming language which has sufficient capabilities can cope with them. There arc problems, however: we need entities whose value is a function--not the application of a function but a function--and these involve some problems.</p><p>Itow to implement efficiently is another very interesting and difficult problem. It means, I think, recognizing certain subsets and transforming them from, say, recursions into loops. This can certainly be done even if they have been written iu terms of recursions and not, as Peter Landin suggested, in terms of already transformed functions like iterate or while.</p><p>I think the last question, "Should DLs be nIixed with impera- tive languages?", clearly has the answer that they should, be- cause at the moment we don't know how to do everything in pure DLs. If you mix declarative and imperative features like this, you may get an apparently large programming language, but the important thing is that it should be simple and easy to define a function. Any language which by mere chance of the way it is writ- ten makes it extremely difficult to write compositions of functions and very easy to write sequences of commands will, of course, in an obvious psychological way, hinder people from using descriptive rather than imperative features. In the long run, I think the effect will delay our understanding of basic similarities, which underlie different sorts of programs and different ways of solving problems.</p><p>Smith: As I understand the declarative languages, there has to be a mixture of imperative and descriptive statements or no com- putation will take place. If I give you a set of simultaneous equa- tions, you may say "yes?", meaning well, what am I supposed to do about it, or you may say "yes", meaning yes I understand, but you don't do anything until I say "now find the values of the vari- ables." In fact, in a well-developed language there is not just one question that I can ask but a number of questions. So, in effect, the declarative statements are like data which you set aside to be u~ed later after I give you the imperatives, of which I had a choice, which get the action.</p><p>Strachey: This is a major point of confusion. There are two ideas here and I think we should try to sort them out. If you give a quadratic equation to a machine and then say "print the value of x", this is not the sort of language that I call a DL. I regard it as an implicit language--that is, one where you give the machine the data and then hope that it will be smart enough to solve the prob- lem for you. It is very different from a language such as LisP, where you define a function explicitly and have only one impera- tive. which says "evaluate this expression and print the result."</p><p>Abrahams: I've clone a fair amount of programming in LisP, and there is one situation which I feel is symptomatic of the times when you really do want an imperative language. It is a situation that arises if you are planning to do programming in pure Lisp and you find that your functions accumulate a large number of argu- ments. This often happens when you have a nmnber of variables and you are actually going through a process and at each stage of the process you want to change the state of the world a little bit-- say, to change one of these variables. So you have the choice of either trying to communicate them all, or trying to do some sort of essentially imperative action that changes one of them. If you try to list all of the transitions from state to state and incorporate them into one function, you'll find that this is not really a very natural kind of function because the natures of the transitions are too different.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Volume 9 / Number 3 / March, 1966</head><p>Communications of the ACM Landin: I said in iny talk that LisP had not gone quite all the way and I think that this difficulty is connected with going all the way. If we write a function definition where the right-hand side is a listing of expressions such as</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F(x) = E1 , E2, E~</head><p>thel~ we can say that this function will produce a three-list as its result. If llOW we have ~mother function G(x, y, z) = E, on some occasion we might have an expression such as G(a 2, b 2, c ~) and we often feel that we should be able to write G(F(t)), and another example which should be allowed is</p><formula xml:id="formula_12">G(a &gt; b --~ E1 , E2 , E3 else E4 , E5 , E6).</formula><p>l am not quite sure but I think you can get around your problem by treating every function as if it were in fact monadic and had a single argument which was the list structure you are trying to process.</p><p>Abrahams: This is a difficulty in other programming languages too; you cannot define a function of an indefinite number of argu- ments.</p><p>Naur: I still don't understand this distinction about an im- plicit language. Does it mean that whenever you have such a language there is a built-in feature for solving equations?</p><p>Abrahams: I think the point is whether you are concerned with the problem or are concerned with the method of solution of the problem.</p><p>Ingerman: I suggest that in the situation where you have speci- fied everything that you want to know, though the exact sequence in which you evoke the various operations to cause the solution is left unspecified, then you have something which is effectively a descriptive language; if you have exactly the same pieces of in- formation, surrounded with promises that you will do this and then this, then you have an imperative language. The significant point is that it is not all or nothing but there is a scale and while it is probably pretty simple to go all the way with imperatives, the chances of being ttble to get all the way descriptive is about zero, but there is a settle and we should recognize this scale.</p><p>Smilh: I think that there is a confusion between implicit or explicit on the one hand and imperative or declarative on the other. These are two separate distinctions and can occur in all combinations. For illstance, an analog computer handles ilnplicit declaratives.</p><p>Young: I think it is fairly obvious that you've got to have the ability for sequencing imperatives in any sort of practical lan- guage. There are many, many cases in which only a certain se- quence of operations will produce the logically correct results. So that we cannot have a purely declarative language, ~e must have a general purpose one. A possible definition of a declarative language is one in which I can make the statements (a), (b), (c) and (d) and indicate whether I mean these to be taken as a se- quence or as a set; that is, must they be performed in a particular order or do I merely mean that so long as they are all performed, they may be performed in any sequence at any time and whenever convenient for efficiency.</p><p>Strachey: You can, in fact, impose an ordering on a language which doesn't have the sequencing of commands by nesting the functional applications.</p><p>Landin: The point is that when you compound functional ex- pressions you are imposing a partial ordering, and when you de- compose this into commands you are unnecessarily giving a lot of inforination about sequencing.</p><p>Strachey: One inconvenient thing about a purely imperative language is that you have to specify far too much sequencing. For example, if you wish to do a matrix multiplication, you have to do n a multiplications. If you write an ordinary program to do this, you have to specify the exact sequence which they are all to be done. Actually, it doesn't matter in what order you do the multi- plications so long as you add them togcther in the right groups. Thus the ordinary sort of imperative language imposes much too much sequencing, which makes it very difficult to rearrange if you want to make things more efficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Syntax-Directed Interpretation of Classes of Pictures</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R. Narasimhan</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tata Institute of Fundamental Research, Bombay, India</head><p>A descriptive scheme for classes of pictures based on label- ing techniques using parallel processing algorithms was pro- posed by the author some years ago. Since then much work has been done in applying this to bubble chamber pictures.</p><p>The parallel processing simulator, originally written for an IBM 7094 system, has now been rewritten for a CDC 3600 system. This paper describes briefly the structure of syntactic descriptive models by considering their specific application to bubble chamber pictures. How the description generated in this phase can be embedded in a larger "conversation" pro- gram is explained by means of a certain specific example that has been worked out. A partial generative grammar for "handwritten" English letters is given, as are also a few com- puter-generated outputs using this grammar and the parallel processing simulator mentioned earlier.</p><p>Presented at an ACM Programming Languages and Pragmatics Conference, San Dimas, California, August, 1965.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Recent active interest in the area of graphic data-based "conversation programs ''1 has pointed up the urgent need for sophisticated picture processing models in a convincing manner. Kitsch <ref type="bibr">[2]</ref> has very ably argued that "from the point of view of computer information processing, the important fact about natural language text and pictures is that both have a syntactic structure which is capable of being described to a machine and of being used for purposes of interpreting the information within a data processing system." "The problem of how to describe the syntactic structure of text and pictures and how to use the syntactic description in interpreting the text and pictures" has been tackled in a certain specific way by Kirsch and his co- workers. (For other references, see <ref type="bibr">[9]</ref>.)</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>x</head><label></label><figDesc>(x-ka) f(b+2c) where x = b -4-2c where f(x) = x(x+a)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>f</head><label></label><figDesc>(b-l-2c) ---I-f(2b--c) where f(x) = x(x-t-a) f(bA--2c) --f(2b-c) where f(x) = x(x+a) and b = u/(u+l) and c = v/(v-t-1)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>2</head><label></label><figDesc>Writing a s t r u c t u r e definition i~volves coining names for the various alternative f o r m a t s of amessage's and their components.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>[</head><label></label><figDesc>x ( x + l ) w h e r e x = a + 2b a mainclause, which is an aexp, or and a support l e t x = a + 2b; x ( x + l ) which is an adef, a n d an adefinition (adef) is either standard, and has</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>f3), (I), (=), (i3) backwards, (Y) backwards, (I') backwards.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>being in the equivalence class that also contains concatenate ('wi', 'he') and append (fiflhletterof (romanalphabet), (threeletterstemof ('winter'))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Print the x such that x 2 --x --6 = 0 /~ x &gt; 0 Such a classification of languages (as opposed to merely expressions within languages) is useless, and even harmful by encouraging stupidly restrictive language design, if it excludes the following: Print square (the x such that x ~ -Print f(1, --1, 6) where f(a, b, c) = the x such that ax ~ ÷ bx + c = 0 A x &gt;_0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>The texts of abstract ISWlM are composite information structures called amessage's. The following structure definition defines ~ the class amessage in terms of a class called identifier. It also defines several functions for manipulating amessage's. These comprise the predicates</head><label>texts</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>elsewhere ~bbreviated to combine), consstandardade], etc. Examples of reference IswI~ are given alongside, against the right margin., which is an aexp, or and a rand, which is an aexp,, which is an aexp, and a teftarm, which is an aexp, and a rightarm, which is an aexp, or one-armed, and has [q-+2a--b a condition, which is an aexp, and an arm, which is an aexp, or a listing, and has [a+b, c+d, e+f a body which is an aexp-list, or beet, and has</head><label></label><figDesc></figDesc><table>An amessage is 

either a demand, and has 
[ P r i n t a+2b 
a body which is an aexprcssion, 

or else a definition, 

[Def x=a+2b 

w h e r e r e c 
an aexpression (aexp) is 

either simple, and has 
[CAth231" 
a body which is an identifier 
or a combination, in which case it has 
[sin(a+2b) 
a ratora + 2b 

or conditional, in which case it is 
either two-armed, and has 
[p--*a+2b; 2a--b 
a condition</table></figure>

			<note place="foot">V o l u m e 9 / N u m b e r 3 / M a r c h , 1966 C o m m u n i c a t i o n s o f t h e ACM</note>

			<note place="foot">Print i(p where p(x)=x2-x-6 A x &gt; O) Print square (i(p where p(x)=x2-x-6 A x &gt; 0)) Print u (u-}-1) where u = i (p where p(x)=x~-x-6 A x &gt; O) Print f(1,-1,-6) where f (a, b, c) = i(p where p(x)=ax2-bbx+c A x &gt; O)</note>

			<note place="foot" n="1"> See [9] for a good survey of work accomplished and in progress in this area, as well as in the general field of &quot;English questionanswer&quot; programs.</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl/>
			</div>
		</back>
	</text>
</TEI>

