<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/doyougnu/School_Files/Hoops_17-18/Fall/SE/tldrResearchPaper/grobid-grobid-parent-0.4.4/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-11-09T04:29+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">How to make ad-hoc polymorphism less ad hoc</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="1988-10">October 1988</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><surname>Wadler</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Glasgow</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Blott</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Glasgow</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">How to make ad-hoc polymorphism less ad hoc</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="1988-10">October 1988</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication , and generalise the \eqtype variables&quot; of Standard ML. Type classes extend the Hindley/Milner polymorphic type system, and provide a new approach to issues that arise in object-oriented programming , bounded type quantiication, and abstract data types. This paper provides an informal introduction to type classes, and deenes them formally by means of type inference rules.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Strachey chose the adjectives ad-hoc and parametric to distinguish two varieties of polymorphism Str67].</p><p>Ad-hoc polymorphism occurs when a function is deened over several diierent types, acting in a dif- ferent way for each type. A typical example is overloaded multiplication: the same symbol may be used to denote multiplication of integers (as in <ref type="bibr">3*3)</ref> and multiplication of oating point values (as in <ref type="bibr">3.14*3.14)</ref>.</p><p>Parametric polymorphism occurs when a function is deened over a range of types, acting in the same way for each type. A typical example is the length function, which acts in the same way on a list of integers and a list of foating point numbers.</p><p>One widely accepted approach to parametric polymorphism is the Hindley/Milner type system Hin69, Mil78, DM82], which is used in Standard ML HMM86, Mil87], Miranda 1 Tur85], and other languages. On the other hand, there is no widely accepted approach to ad-hoc polymorphism, and so its name is doubly appropriate.</p><p>This paper presents type classes, which extend the Hindley/Milner type system to include certain kinds of overloading, and thus bring together the two sorts of polymorphism that Strachey separated.</p><p>The type system presented here is a generalisa- tion of the Hindley/Milner type system. As in that system, type declarations can be inferred, so explicit type declarations for functions are not required. Dur- ing the inference process, it is possible to translate a program using type classes to an equivalent program that does not use overloading. The translated pro- grams are typable in the (ungeneralised) Hindley/ Milner type system.</p><p>The body of this paper gives an informal introduc- tion to type classes and the translation rules, while an appendix gives formal rules for typing and trans- lation, in the form of inference rules (as in nDM82]). The translation rules provide a semantics for type classes. They also provide one possible implementa- tion technique: if desired, the new system could be added to an existing language with Hindley/Milner types simply by writing a pre-processor.</p><p>Two places where the issues of ad-hoc polymor- phism arise are the deenition of operators for arith- metic and equality. Below we examine the ap- proaches to these three problems adopted by Stan- dard ML and Miranda; not only do the approaches diier between the two languages, they also diier within a single language. But as we shall see, type classes provide a uniform mechanism that can ad- dress these problems.</p><p>This work grew out of the eeorts of the Haskell committee to design a lazy functional programming language <ref type="bibr">2</ref> . One of the goals of the Haskell commit- tee was to adopt \oo the shelf" solutions to problems wherever possible. We were a little surprised to re- alise that arithmetic and equality were areas where no standard solution was available! Type classes were developed as an attempt to nd a better so- lution to these problems; the solution was judged successful enough to be included in the Haskell de- sign. However, type classes should be judged inde- pendently of Haskell; they could just as well be in- corporated into another language, such as Standard ML.</p><p>Type classes appear to be closely related to issues that arise in object-oriented programming, bounded quantiication of types, and abstract data types CW85, MP85, Rey85]. Some of the connections are outlined below, but more work is required to under- stand these relations fully.</p><p>A type system very similar to ours has been dis- covered independently by Stefan Kaes sKae88]. Our work improves on Kaes' in several ways, notably by the introduction of type classes to group re- lated operators, and by providing a better transla- tion method.</p><p>This paper is divided into two parts: the body gives an informal introduction to type classes, while the appendix gives a more formal description. Sec- tion 2 motivates the new system by describing limi- tations of ad-hoc polymorphism as it is used in Stan- dard ML and Miranda. Section 3 introduces type classes by means of a simple example. Section 4 illustrates how the example of Section 3 may be translated into an equivalent program without type classes. Section 5 presents a second example, the def- inition of an overloaded equality function. Section 6 describes subclasses. Section 7 discusses related work and concludes. Appendix A presents inference rules for typing and translation. arithmetic and equality in <ref type="bibr">Standard ML and Miranda.</ref> Arithmetic. In the simplest approach to overload- ing, basic operations such as addition and multiplica- tion are overloaded, but functions deened in terms of them are not. For example, although one can write <ref type="bibr">3</ref> This is the approach taken in Standard ML. (Inci- dentally, it is interesting to note that although Stan- dard ML includes overloading of arithmetic opera- tors, its formal deenition is deliberately ambiguous about how this overloading is resolved dHMT88, page 71], and diierent versions of Standard ML resolve overloading in diierent ways.)</p><p>A more general approach is to allow the above equation to stand for the deenition of two over- loaded versions of square, with types Int -&gt; Int and Float -&gt; Float. But consider the function:</p><p>squares (x, y, z) = (square x, square y, square z)</p><p>Since each of x, y, and z might, independently, have either type Int or type Float, there are eight possi- ble overloaded versions of this function. In general, there may be exponential growth in the number of translations, and this is one reason why such solu- tions are not widely used.</p><p>In Miranda, this problem is side-stepped by not overloading arithmetic operations. Miranda provides only the oating point type (named \num"), and there is no way to use the type system to indicate that an operation is restricted to integers.</p><p>Equality. The history of the equality operation is checkered: it has been treated as overloaded, fully polymorphic, and partly polymorphic.</p><p>The erst approach to equality is to make it over- loaded, just like multiplication. In particular, equal- ity may be overloaded on every monotype that ad- mits equality, i.e., does not contain an abstract type or a function type. In such a language, one may write 3*4 == 12 to denote equality over integers, or 'a' == 'b' to denote equality over characters. But one cannot deene a function member by the equations member ] y = False member (x:xs) y = (x == y) \/ member xs y and then write terms such as member 1,2,3] 2 member "Haskell" 'k'</p><p>(We abbreviate a list of characters <ref type="bibr">'a','b','c']</ref> as "abc".) This is the approach taken in the rst version of <ref type="bibr">Standard ML LMil84]</ref>.</p><p>A second approach is to make equality fully poly- morphic. In this case, its type is</p><formula xml:id="formula_0">(==) :: a -&gt; a -&gt; Bool</formula><p>where a is a type variable ranging over every type. The type of the member function is now member :: a] -&gt; a -&gt; Bool <ref type="bibr">(We write a]</ref> for the type \list of a".) This means that applying equality to functions or abstract types does not generate a type error. This is the approach taken in Miranda: if equality is applied on a func- tion type, the result is a run-time error; if equality is applied on an abstract type, the result is to test the representation for equality. This last may be consid- ered a bug, as it violates the principle of abstraction.</p><p>A third approach is to make equality polymorphic in a limited way. In this case, its type is (==) :: a (==) -&gt; a (==) -&gt; Bool where a (==) is a type variable ranging only over types that admit equality. The type of the member function is now member :: a (==) ] -&gt; a (==) -&gt; Bool Applying equality, or member, on a function type or abstract type is now a type error. This is the ap- proach currently taken in Standard ML, where a (==) is written ''a, and called an \eqtype variable".</p><p>Polymorphic equality places certain demands upon the implementor of the run-time system. For in- stance, in Standard ML reference types are tested for equality diierently from other types, so it must be possible at run-time to distinguish references from other pointers.</p><p>Object-oriented programming. It would be nice if polymorphic equality could be extended to include user-deened equality operations over abstract types. To implement this, we would need to require that every object carry with it a pointer to a method, a procedure for performing the equality test. If we are to have more than one operation with this property, then each object should carry with it a pointer to a dictionary of appropriate methods. This is exactly the approach used in object-oriented programming GR83].</p><p>In the case of polymorphic equality, this means that both arguments of the equality function will contain a pointer to the same dictionary (since they are both of the same type). This suggests that per- haps dictionaries should be passed around indepen- dently of objects; now polymorphic equality would be passed one dictionary and two objects (minus dic- tionaries). This is the intuition behind type classes and the translation method described here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">An introductory example</head><p>We will now introduce type classes by means of an example.</p><p>Say that we wish to overload (+), (*), and negate (unary minus) on types Int and Float. To do so, we introduce a new type class, called Num, as shown in the class declaration in <ref type="figure">Figure 1</ref>. This declaration may be read as stating \a type a belongs to class Num if there are functions named (+), (*), and negate, of the appropriate types, deened on it."</p><p>We may now declare instances of this class, as shown by the two instance declarations in <ref type="figure">Figure 1</ref>. The assertion Num Int may be read \there are func- tions named (+), (*), and negate, of the appropri- ate types, deened on Int". The instance declaration justiies this assertion by giving appropriate bindings for the three functions. The type inference algorithm must verify that these bindings do have the appropri- ate type, i.e., that addInt has type Int-&gt;Int-&gt;Int, and similarly for mulInt and negInt. (We assume that addInt, mulInt, and negInt are deened in the standard prelude.) The instance Num Float is de- clared similarly.</p><p>A word on notational conventions: Type class names and type constructor names begin with a capi- tal letter, and type variable names begin with a small letter. Here, Num is a type class, Int and Float are type constructors, and a is a type variable.</p><p>We may now deene</p><formula xml:id="formula_1">square x = x * x</formula><p>There exists an algorithm that can infer the type of square from this deenition (it is outlined in the appendix). It derives the type:  and an appropriate type will be derived for each (Int for the rst expression, Float for the second). On the other hand, writing square 'x' will yield a type error at compile time, because Char has not been asserted (via an instance declaration) to be a numeric type. Finally, if we deene the function squares men- tioned previously, then the type given in <ref type="figure">Figure 1</ref> will be inferred. This type may be read, \squares has the type (a,b,c) -&gt; (a,b,c) for every a, b, and c such that a, b, and c belong to class <ref type="bibr">Num".</ref> (We write <ref type="bibr">(a,b,c)</ref> for the type that is the cartesian product of a, b, and c.) So squares has one type, not eight. Terms such as squares <ref type="bibr">(1, 2, 3.14)</ref> are legal, and derive an appropriate type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Translation</head><p>One feature of this form of overloading is that it is possible at compile-time to translate any pro- gram containing class and instance declarations to an equivalent program that does not. The equiva- lent program will have a valid Hindley/Milner type.</p><p>The translation method will be illustrated by means of an example. <ref type="figure">Figure 2</ref> shows the transla- tion of the declarations in <ref type="figure">Figure 1</ref>.</p><p>For each class declaration we introduce a new type, corresponding to an appropriate \method dic- tionary" for that class, and functions to access the methods in the dictionary. In this case, correspond- ing to the class Num we introduce the type NumD as shown in <ref type="figure">Figure 2</ref>. The data declaration deenes NumD to be a type constructor for a new type. Values of this type are created using the value constructor NumDict, and have three components of the types shown. The functions add, mul, and neg take a value of type NumD and return its rst, second, and third component, respectively.</p><p>Each instance of the class Num is translated into the declaration of a value of type NumD. Thus, corre- sponding to the instance Num Int we declare a data structure of type NumD Int, and similarly for Float.</p><p>Each term of the form x+y, x*y, and negate x is now replaced by a corresponding term, as follows:</p><formula xml:id="formula_2">x+y --&gt; add numD x y x*y --&gt; mul numD x y negate x --&gt; neg numD x</formula><p>where numD is an appropriate dictionary. How is the appropriate dictionary determined? By its type. For example, we have the following translations: Finally, the translation of squares is also shown in <ref type="figure">Figure 2</ref>. Just as there is one type, rather than eight, there is only one translation, rather than eight. Exponential growth is avoided.</p><formula xml:id="formula_3">3 * 3 --&gt; mul</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">A further example: equality</head><p>This section shows how to deene equality using class and instance declarations. Type classes serve as a straightforward generalisation of the \eqtype vari- ables" used in Standard ML. Unlike Standard ML, this mechanism allows the user to extend equality over abstract types in a straightforward way. And, unlike Standard ML, this mechanism can be trans- lated out at compile time, so it places no special de- mands on the implementor of the run-time system. The deenition is summarised in <ref type="figure" target="#fig_1">Figure 3</ref>. We be- gin by declaring a class, Eq, containing a single op- erator, (==), and instances Eq Int and Eq Char of this class.</p><p>We then deene the member function in the usual way, as shown in <ref type="figure" target="#fig_1">Figure 3</ref>. The type of member need not be given explicitly, as it can be inferred. The inferred type is:</p><formula xml:id="formula_4">member :: Eq a =&gt; a] -&gt; a -&gt; Bool</formula><p>This is read \member has type a] -&gt; a -&gt; Bool, for every type a such that a is in class Eq (i.e., such that equality is deened on a)" (This is exactly equivalent to the Standard ML type ''a list-&gt;''a-&gt;bool, where ''a is an \eqtype variable".) We may now write terms such as member 1,2,3] 2 member "Haskell" 'k' which both evaluate to True.</p><p>Next, we give an instance deening equality over pairs. The erst line of this instance reads, \for every a and b such that a is in class Eq and b is in class Eq, the pair (a,b) is also in class Eq." In other words, \if equality is deened on a and equality is deened on b, then equality is deened on (a,b)." The instance deenes equality on pairs in terms of equality on the two components, in the usual way.</p><p>Similarly, it is possible to deene equality over lists. The rst line of this instance reads, \if equality is deened on a, then equality is deened on typèlist of a'." We may now write terms such as The enal data declaration deenes a new type con- structor Set and a new value constructor MkSet. If a module exports Set but hides MkSet, then out- side of the module the representation of Set will not be accessible; this is the mechanism used in Haskell to deene abstract data types. The enal instance de- nes equality over sets. The erst line of this instance reads, \if equality is deened on a, then equality is deened on typèset of a'." In this case, sets are rep- resented in terms of lists, and two sets are taken to be equal if every member of the rst is a member of the second, and vice-versa. (The deenition uses standard functions map, which applies a function to every element of a list, and and, which returns the conjunction of a list of booleans.) Because set equal- ity is deened in terms of member, and member uses overloaded equality, it is valid to apply equality to sets of integers, sets of lists of integers, and even sets of sets of integers. This last example shows how the type class mech- anism allows overloaded functions to be deened over abstract data types in a natural way. In particular, this provides an improvement over the treatment of equality provided in Standard ML or Miranda.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Translation of equality</head><p>We now consider how the translation mechanism ap- plies to the equality example. <ref type="figure" target="#fig_3">Figure 4</ref> shows the translation of the declarations in <ref type="figure" target="#fig_1">Figure 3</ref>. The rst part of the translation intro- duces nothing new, and is similar to the translation in Section 4. We begin by deening a dicitionary EqD correspond- ing to the class Eq. In this case, the class contains only one operation, (==), so the dictionary has only one entry. The selector function eq takes a dictio- nary of type EqD a and returns the one entry, of type a-&gt;a-&gt;Bool. Corresponding to the instances Eq Int and Eq Char we deene two dictionaries of types EqD Int and EqD Char, containing the appro- priate equality functions, and the function member is translated to member' in a straightforward way. Here are three terms and their translations:  The remainder of the translation is shown in <ref type="figure" target="#fig_3">Figure  4</ref>, as is the translation for equality over pairs. Here are three terms and their translations:</p><p>"hello" == "goodbye" --&gt; eq (eqDList eqDChar) "hello" "goodbye" member "Haskell", "Alonzo"] "Moses" --&gt; member' (eqDList eqDChar) "Haskell", "Alonzo"] "Moses"</p><p>As an optimisation, it is easy for the compiler to per- form beta reductions to transform terms of the form eq (eqDList eqD) into eqList eqD, where eqD is any dictionary for equality. This optimisation may be applied to the erst two examples above, and also to the deenition of eqList itself in <ref type="figure" target="#fig_3">Figure 4</ref>. It is worthwhile to compare the eeciency of this translation technique with polymorphic equality as found in Standard ML or Miranda. The individual operations, such as eqInt are slightly more eecient than polymorphic equality, because the type of the argument is known in advance. On the other hand, operations such as member and eqList must explic- itly pass an equality operation around, an overhead that polymorphic equality avoids. Further experi- ence is needed to asses the trade-oo between these costs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Subclasses</head><p>In the preceeding, Num and Eq were considered as completely separate classes. If we want to use both numerical and equality operations, then these each appear in the type separately: memsq :: Eq a, Num a =&gt; a]-&gt;a-&gt;Bool memsq xs x = member xs (square x) As a practical matter, this seems a bit odd|we would expect every data type that has (+), (*), and negate deened on it to have (==) deened as well; but not the converse. Thus it seems sensible to make Num a subclass of Eq.</p><p>We can do this as follows: The relationships among these types can be dia- grammed as follows:</p><formula xml:id="formula_5">Top / \ / \ Left Right \ / \ / Bottom</formula><p>Although multiple superclasses pose some prob- lems for the usual means of implementing object- oriented languages, they pose no problems for the translation scheme outlined here. The translation simply assures that the appropriate dictionaries are passed at run-time; no special hashing schemes are required, as in some object-oriented systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>It is natural to think of adding assertions to the class declaration, specifying properties that each instance must satisfy: It is valid for any proof to rely on these properties, so long as one proves that they hold for each instance declaration. Here the assertions have simply been written as comments; a more sophisticated system could perhaps verify or use such assertions. This sug- gests a relation between classes and object-oriented programming of a diierent sort, since class declara- tions now begin to resemble object declarations in OBJ JFGJM85]. It is possible to have overloaded constants, such as zero and one in the above example. However, unre- stricted overloading of constants leads to situations where the overloading cannot be resolved without providing extra type information. For instance, the expression one * one is meaningless unless it is used in a context that speciies whether its result is an Int or a Float. For this reason, we have been careful in this paper to use constants that are not overloaded: <ref type="bibr">3</ref> has type Int, and 3.14 has type Float. A more general treatment of constants seems to require co- ercion between subtypes.</p><p>It is reasonable to allow a class to apply to more than one type variable. For instance, we might have In this case, the assertion Coerce a b might be taken as equivalent to the assertion that a is a sub- type of b. This suggests a relation between this work and work on bounded quantiication and on subtypes (see eCW85, Rey85] for excellent surveys of work in this area, and dWan87, Car88] for more recent work). Type classes may be thought of as a kind of bounded quantiier, limiting the types that a type variable may instantiate to. But unlike other ap- proaches to bounded quantiication, type classes do not introduce any implicit coercions (such as from subtype Int to supertype Float, or from a record with helds x, y, and z to a record with helds x and y). Further exploration of the relationship between type classes and these other approaches is likely to be fruitful.</p><p>Type classes also may be thought of as a kind of abstract data type. Each type class speciies a collection of functions and their types, but not how they are to be implemented. In a way, each type class corresponds to an abstract data type with many implementations, one for each instance dec- laration. Again, exploration of the relationship be- tween type classes and current work on abstract data types sCW85, MP85, Rey85] appears to be called for.</p><p>We have already referred to the work of Kaes. One advance of our work over his is the conceptual and notational beneet of grouping overloaded functions into classes. In addition, our system is more gen- eral; Kaes cannot handle overloadings involving more than one type variable, such as the coerce example above. Finally, our translation rules are an improve- ment over his. Kaes outlines two sets of translation rules (which he calls \semantics"), one static and one dynamic. His dynamic semantics is more limited in power than the language described here; his static semantics appears similar in power, but, unlike the translation described here, can greatly increase the size of a program.</p><p>One drawback of our translation method is that it introduces new parameters to be passed at run- time, corresponding to method dictionaries. It may be possible to eliminate some of these costs by us- ing partial evaluation BEJ88] to generate versions of functions specialised for certain dictionaries; this would reduce run time at the cost of increasing code size. Further work is needed to assess the trade-oos between our approach (with or without partial eval- uation) and other techniques.</p><p>It is clear from the above that many issues remain to be explored, and many tradeoos remain to be as- sessed. We look forward to the practical experience with type classes that Haskell will provide.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Typing and translation rules</head><p>This appendix presents the formal typing and trans- lation rules, one set of rules performing both typing and translation. The rules are an extension of those given by Damas and Milner rDM82].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Language</head><p>To present the typing and translation rules for over- loading, it is helpful to use a slightly simpler language that captures the essential issues. We will use a lan- guage with the usual constructs (identiiers, appli- cations, lambda abstractions, and let expressions), plus two new constructs, over and inst expressions, that correspond to class and instance declarations, respectively. The syntax of expressions and types is given in <ref type="figure">Figure 5</ref>.</p><p>An over expression over x :: in e declares x to be an overloaded identiier. Within the scope of this declaration, there may be one or more corresponding inst expressions inst x :: 0 = e 0 in e 1 where the type 0 is an instance of the type (a notion to be made precise later). Unlike lambda and let expressions, the bound variables in over and inst expressions may not be redeclared in a smaller scope. Also unlike lambda and let expressions, over and inst expressions must contain explicit types; the types in other expressions will be inferred by the rules given here.</p><p>As an example, a portion of the deenition of equal- ity given in <ref type="figure" target="#fig_1">Figure 3</ref> is shown in <ref type="figure">Figure 6</ref>. In this gure, and in the rest of this appendix, we use Eq as an abbreviation for the type ! ! Bool.</p><p>As a second example, a portion of the deenition of arithmetic operators given in <ref type="figure">Figure 1</ref> is shown in <ref type="figure">Figure 7</ref>. In this sgure we use Num as an abbrevi- ation for the type ( ! ! ; ! ! ; ! )</p><p>In translating to the formal language, we have grouped the three operators together into a \dictio- nary". This is straightforward, and independent of the central issue: how to resolve overloading.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Types</head><p>The Damas/Milner system distinguishes between types (written ) and type schemes (written ). Our system adds a third syntactic group, predicated types. The syntax of these is given in <ref type="figure">Figure 5</ref>.</p><p>In the full language, we wrote types such as member :: Eq a =&gt; a] -&gt; a -&gt; Bool</p><p>In the simpliied language, we write this in the form member :: 8: (eq :: Eq ): ] ! ! Bool The restriction Eq a can be read \equality is deened on type a" and the corresponding restriction (eq :: Eq ) can be read \eq must have an instance of type Eq ".</p><p>In general, we refer to (x :: ): : as a predicated type and (x :: ) as a predicate.</p><p>We will give rules for deriving typings of the form A ` e :: n e This can be read as, \under the set of assumptions A, the expression e has well-typing with transla- tion e". Each typing also includes a translation, so the rules derive typingntranslation pairs. It is possi- ble to present the typing rules without reference to the translation, simply by deleting thène' portion from all rules. It is not, however, possible to present the translation rules independently, since typing con- trols the translation. For example, the introduction and elimination of predicates in types controls the introduction and elimination of lambda abstractions in translations. In (x :: n x) and (x :: i n x), the identiier x is the translation of x. If x is not an overloaded identiier (that is, if x is bound by a lambda or let expression), then the assumption for x has the form (x :: n x), so x simply translates as itself. <ref type="figure">Figure 8</ref> shows the assumptions available when ap- plying the inference rules to the expression p: :q: eq (fst p) (fstq) ^ eq (snd p) (sndq) in <ref type="figure">Figure 6</ref>. There are three (:: i ) bindings, corre- sponding to the three instance declarations, and two (::) bindings for the two bound variables, and two (::) bindings corresponding to assumed instances of equality. (We shall see later how assumed instances are introduced by the PRED rule.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4 Instances</head><p>Given a set of assumptions A, we deene an instance relation between type-schemes,</p><formula xml:id="formula_6">A 0 :</formula><p>This can be read as \ is more general than 0 under assumptions A". This is the same as the relationship deened by Damas and Milner, but extended to apply to predicated types.</p><p>Only certain sets of assumptions are valid. The deenition of validity depends on the A relation, so there is a (well-founded) mutual recursion between the deenition of valid assumptions and the deenition of A . We give the deenition of A in this section, and the deenition of valid assumptions in the next.  Two type-schemes are uniiable if they overlap, that is, if there exists a type that is an instance of both under some set of assumptions. We say that and 0 are uniiable if there exists a type and valid set of assumptions A such that  is a valid assumption set.</p><p>Overloaded identiier. If A is a valid assumption set, x is an identiier that does not appear in A, is a type scheme, and 1 ; : : :; ; m are types and 1 ; : : :; ; n are types schemes such that { A i , for i from 1 to n, and { A i , for i from 1 to m, and { i # j , for distinct i; j from 1 to n then A; (x :: o ); (x :: i 1 n x 1 ); : : :; (x :: i n n x n ); (x :: 1 n x 1 ); : : :; (x :: m n x m ) is a valid assumption set. For example, the assumptions in <ref type="figure">Figure 8</ref> are a valid set. However, this set would be invalid if aug- mented with the binding (eq :: i 8:Eq (Char; ;) n eq (8:Eq (Char;;)) ) as this instance overlaps with one already in the set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.6 Inference rules</head><p>We now give inference rules that characterise well- typings of the form For example, let A 0 be the set of assumptions shown in <ref type="figure">Figure 8</ref>, together with assumptions about the types of integer and character constants. Then the above rules are suucient to derive that A 0 ` (eq 1 2) :: Bool n (eq (Eq Int) 1 2) A 0 ` (eqà' `b') :: Bool n (eq (Eq Char) `a' `b') That is, these rules alone are suucient to resolve simple overloading.</p><p>More complicated uses of overloading require the remaining four rules, shown in <ref type="figure">Figure 10</ref>. The erst two deal with the introduction and elimination of predicates, and the second two deal with the over and inst constructs.</p><p>As we have seen, expressions with types that con- tain classes (that is, expressions with predicated types) are translated to lambda abstractions that require a dictionary to be passed at run-time. This idea is encapsulated in the PRED (\predicate") and REL (\release") rules. The PRED and REL rules introduce and eliminate predicates analogously to the way that the GEN and SPEC rules introduce and eliminate bound type variables. In particular, the PRED rule adds a predicate to a type (and has a lambda expression as its translation) and the REL rule removes a predicate from a type (and has an ap- plication as its translation).</p><p>The OVER rule types over expressions adding the appropriate (:: o ) binding to the environment, and the INST rule types inst expressions adding the appropriate (:: i ) binding to the environment. The validity condition on sets of assumptions ensures that overloaded identiiers are only instanced at valid types.</p><p>Notice that none of the translations contain over or inst expressions, therefore, they contain no over- loading. It is easy to verify that the translations are themselves well-typed in the Hindley/Milner system.</p><p>For example, the program in <ref type="figure">Figure 6</ref> is translated by these rules into the program in <ref type="figure">Figure 11</ref>. The reader can easily verify that this corresponds to the translation from <ref type="figure" target="#fig_1">Figure 3</ref> to <ref type="figure" target="#fig_3">Figure 4</ref>. We have thus shown how to formalise the typing and transforma- tion ideas that were presented informally in the body of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.7 Principal typings</head><p>Given A and e, we call a principal type scheme for e under A ii A ` e :: n e; and for every 0 , if A ` e :: 0 n e 0 then A 0 A key result in the Hindley/Milner system is that every expression e that has a well-typing has a prin- cipal type scheme.</p><p>We conjecture that for every valid set of assump- tions A and every expression e containing no over or inst expressions, if e has a well-typing under A then e has a principal type scheme under A. For example, let A 0 be the set of assumptions in <ref type="figure">Figure 8</ref>. Then the typing A 0 ` eq :: 8:Eq n eq <ref type="bibr">(Eq alpha)</ref> is principal. Examples of non-principal typings are A 0 ` eq :: Eq Int n eq (Eq Int) A 0 ` eq :: Eq Char n eq <ref type="bibr">(Eq Char)</ref> Each of these is an instance of the principal typing under assumptions A 0 .</p><p>The existence of principal types is problematic for expressions that contain over and inst expressions.</p><p>For example, let A 1 and e 1 be the assumption set and expression in <ref type="figure" target="#fig_0">Figure 12</ref>. Then it is possible to derive the typings A 1 ` e 1 :: Eq Int n eqInt A 1 ` e 1 :: Eq Char n eqChar But there is no principal type! One possible resolu- tion of this is to require that over and inst declara- tions have global scope. It remains an open question whether there is some less drastic restriction that still ensures the existence of principal types.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>Figure 1: Deenition of arithmetic operations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Deenition of equality</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Haskell", "Alonzo"] "Moses" which all evaluate to False.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Translation of equality</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Haskell" 'k' --&gt; member' eqDChar "Haskell" 'k'</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 5 :Figure 7 :Figure 9 :</head><label>579</label><figDesc>Figure 5: Syntax of expressions and types</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>The instance relation A 0 where = 8 1 : : :: n : : and 0 = 8 1 : : :: m : : 0 , is deened as follows: A 0 ii (1) i is not free in and (2) 9 1 ; : : :; ; n : 1 == 1 ; : : :; ; n == n ] A 0 This part is similar to the deenition in Damas/ Milner. The bound variables of are specialised and the resulting predicated types are compared. Deene A 0 ii the type part of equals the type part of 0 (the same condition as Damas/Milner), and for every predicate (x :: ) in , either there is a predicate of the form (x :: ) in 0 (i.e. the predicate appears in both types); or the predicate can be eliminated under assump- tions A. A predicate (x :: ) can be eliminated under A ii either (x :: n x) is in A; or (x :: i 0 n x) is in A and 0 A . For example, if A 0 is the set of assumptions in Figure 8, then (8: (eq :: Eq ): ] ! ! Bool) A0 ((Int] ! Int ! Bool) holds. On the other hand,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>A</head><label></label><figDesc>Figure 10: Typing and translation rules, part 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>A</head><label></label><figDesc>` e :: n e The rules break into two groups, shown in Figures 9 and 10. The rst group is based directly on the Damas/Milner rules (Figure 9). There are two small diierences: translations have been added to each rule in a straightforward way, and there are two TAUT rules instead of one (one rule for (::) bindings and one for (:: i ) bindings).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head></head><label></label><figDesc>This asserts that a may belong to class Num only if it also belongs to class Eq. In other words, Num is a subclass of Eq, or, equivalently, Eq is a superclass of Num. The instance declarations remain the same as before|but the instance declaration Num Int is only valid if there is also an instance declaration Eq Int active within the same scope. From this it follows that whenever a type contains Num a it must also contain Eq a; therefore as a con- venient abbreviation we permit Eq a to be omitted from a type whenever Num a is present. Thus, for the type of memsq we could now write memsq :: Num a =&gt; a]-&gt;a-&gt;Bool The qualiier Eq a no longer needs to be mentioned, because it is implied by Num a. In general, each class may have any number of sub or superclasses. Here is a contrived example:</figDesc><table>class Eq a =&gt; Num a where 
(+) 
:: a -&gt; a -&gt; a 
(*) 
:: a -&gt; a -&gt; a 
negate :: a -&gt; a 

class Top a where 
fun1 :: a -&gt; a 

class Top a =&gt; Left a where 
fun2 :: a -&gt; a 

class Top a =&gt; Right a where 
fun3 :: a -&gt; a 

class Left a, Right a =&gt; Bottom a 
where 
fun4 :: a -&gt; a 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>A .5 Valid assumptions</head><label>A</label><figDesc></figDesc><table>All sets of assumptions used within proofs must be 
valid. The valid sets of assumptions are inductively 
deened as follows: 

Empty. The empty assumption set, fg, is valid. 
Normal identiier. If A is a valid assumption set, 
x is an identiier that does not appear in A, and 
is a type scheme, then 

A; (x :: n x) 

</table></figure>

			<note place="foot" n="1"> Miranda is a trademark of Research Software Limited.</note>

			<note place="foot" n="2"> Limitations of ad-hoc polymorphism This section motivates our treatment of ad-hoc polymorphism, by examining problems that arise with 2 The Haskell committee includes: Arvind, Brian Boutel,</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bjjrner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ershov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">D</forename><surname>Jones</surname></persName>
		</author>
		<title level="m">Partial Evaluation and Mixed Computation</title>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On understanding types, data abstraction, and polymorphism</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Wegner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<date type="published" when="1985-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Structural subtyping and the notion of power type</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15&apos;th Annual Symposium on Principles of Programming Languages</title>
		<meeting>the 15&apos;th Annual Symposium on Principles of Programming Languages<address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Principal type schemes for functional programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dm82] L</forename><surname>Damas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9&apos;th Annual Symposium on Principles of Programming Languages</title>
		<meeting>the 9&apos;th Annual Symposium on Principles of Programming Languages<address><addrLine>Albuquerque</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Principles of OBJ2</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Futasagi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-P</forename><surname>Jouannaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12&apos;th Annual Symposium on Principles of Programming Languages</title>
		<meeting>the 12&apos;th Annual Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1985-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Smalltalk80: The Language and Its Implementation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Robson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The principal type scheme of an object in combinatory logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hindley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. Am. Math. Soc</title>
		<imprint>
			<biblScope unit="volume">146</biblScope>
			<date type="published" when="1969" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Macqueen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Standard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986" />
		</imprint>
		<respStmt>
			<orgName>Edinburgh University, Computer Science Dept.</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Report ECS-LFCS-86-2</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">The deenition of Standard ML, version 2. Report ECS-LFCS-88-62</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tofte</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
		</imprint>
		<respStmt>
			<orgName>Edinburgh University, Computer Science Dept.</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">]</forename><forename type="middle">S</forename><surname>Kae88</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Parametric</forename><surname>Kaes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Polymorphism</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2&apos;nd European Symposium on Programming</title>
		<meeting>the 2&apos;nd European Symposium on Programming<address><addrLine>Nancy, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1988-03" />
			<biblScope unit="volume">300</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A theory of type polymorphism in programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="348" to="375" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A proposal for Standard ML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Lisp and Functional Programming</title>
		<meeting>the Symposium on Lisp and Functional Programming<address><addrLine>Austin, Texas</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Changes to the Standard ML core language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">]</forename><forename type="middle">R</forename><surname>Mil87</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Milner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987" />
		</imprint>
		<respStmt>
			<orgName>Edinburgh University, Computer Science Dept.</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Report ECS-LFCS-87-33</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Abstract types have existential type</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12&apos;th Annual Symposium on Principles of Programming Languages</title>
		<meeting>the 12&apos;th Annual Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1985-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Three approaches to type structure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">]</forename><forename type="middle">J C</forename><surname>Rey85</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mathematical Foundations of Software Development</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1985" />
			<biblScope unit="volume">185</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fundamental concepts in programming languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Strachey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Lecture notes for International Summer School in Computer Programming</title>
		<meeting><address><addrLine>Copenhagen, Au</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1967" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A non-strict functional language with polymorphic types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Turner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miranda</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2&apos;nd International Conference on Functional Programming Languages and Computer Architecture</title>
		<meeting>the 2&apos;nd International Conference on Functional Programming Languages and Computer Architecture<address><addrLine>Nancy, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1985-09" />
			<biblScope unit="volume">201</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Complete type inference for simple objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Logic in Computer Science</title>
		<meeting>the Symposium on Logic in Computer Science<address><addrLine>Ithaca, NY</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1987-06" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>

