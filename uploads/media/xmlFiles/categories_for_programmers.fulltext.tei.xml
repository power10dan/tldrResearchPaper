<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/doyougnu/School_Files/Hoops_17-18/Fall/SE/tldrResearchPaper/grobid-grobid-parent-0.4.4/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-11-09T04:29+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Categories and Haskell</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<title level="a" type="main">Categories and Haskell</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Preface</head><p>This document contains notes for a small-scale seminar on category theory in the context of (functional) programming, organized at Centrum Wiskunde &amp; Informat- ica, the national Dutch research centre for mathematics and computer science. The goal of the seminar is to gain familiarity with concepts of category theory (and other branches of mathematics) that apply (in a broad sense) to the field of functional programming.</p><p>Although the main focus is on the mathematics, examples are given in Haskell to illustrate how to apply the concepts. In some places, examples are given in other languages as well (such as Python and C++).</p><p>I would like to thank:</p><p>• Tom Bannink for supplying the proof for the bifunctor example.</p><p>• Peter Kristel for valuable comments on the Yoneda embedding • Willem Jan Palenstijn for corrections and comments regarding cartesian closed categories.</p><p>• Tom de Jong for examples and suggestions for the section on adjunctions And everyone else who has attended or contributed to the seminar.</p><p>-Jan-Willem Buurlage (janwillembuurlage@gmail.com)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>Today, the most common programming style is imperative. Imperative program- ming lets the user describes how a program should operate, mostly by directly changing the memory of a computer. Most computer hardware is imperative; a pro- cessor executes a machine code sequence, and this sequence is certainly imperative. Imperative programming was first treated by mathematicians such as Turing and von Neuman in the 30s.</p><p>A different way of programming is declarative programming, which is a way of expressing what you want the program to compute (without explicitely saying how it should do this). A good way of expressing what you want to have computed, is by describing your program mathematically, i.e. using functions. This exactly what we will explore. The functional style of looking at computations is based on work done in the 20s/30s by Curry and Church among others.</p><p>Partically speaking, the difficulty in using a (typed, pure) functional programming language, is that the functions that you write between types should behave like mathematical functions on the corresponding sets. This means, for example, that if you call a function multiple times with the same arguments, it should produce the same result every time. This is often summarized as a side-effect free function. More generally, values are in principle immutable.</p><p>Something else that would allow us to more accurately describe our programs in a mathematical way is if execution is lazy (which is the case in e.g. Haskell). This means we can work with infinite lists and sequences, and only peeking inside such a list causes the necessary computations to be done.</p><p>In these notes I will assume some 'mathematical maturity' from the reader, but I have tried throughout to keep everything as simple as possible. There is certainly some advanced mathematics to be found, and for those who have not encountered abstract mathematics some sections may be hard to follow. In any case, as a rule there are no overly exotic examples. All the concepts introduced should be accompanied by practical and understandable examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Part I</head><p>Basic theory <ref type="bibr">7</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 1</head><p>Categories, functors and natural transformations <ref type="bibr" target="#b2">1</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.1 Core definitions</head><p>We start with giving the definition of a category: Definition 1.1. A category C = (O, A, •) consists of:</p><p>• a collection O of objects, written a, b, . . . ∈ O.</p><p>• a collection A of arrows written f, g, . . . ∈ A between these objects, e.g. f : a → b.</p><p>• a notion of composition f • g of arrows.</p><p>• an identity arrow id a for each object a ∈ O.</p><p>The composition operation and identity arrow should satisfy the following laws:</p><p>• Saying a diagram commutes means that for all pairs of vertices a and b all paths from between them are equivalent (i.e. correspond to the same arrow of the category).</p><p>If f : a → b, then we say that a is the domain and b is the codomain of b. It is also written as: dom(f ) = a, cod(f ) = b.</p><p>The composition g • f is only defined on arrows f and g if the domain of g is equal to the codomain of f .</p><p>We will write for objects and arrows respectively simply a ∈ C and f ∈ C, instead of a ∈ O and f ∈ A. In all these cases, arrows correspond to functions, although this is by no means required. All these categories correspond to objects from mathematics, along with structure preserving maps. Set will also play a role when we discuss the category Hask when we start talking about concrete applications to Haskell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Examples of categories</head><p>There are also a number of simple examples of categories:</p><p>• 0, the empty category O = A ≡ ∅.</p><p>• 1, the category with a single element and (identity) arrow:</p><formula xml:id="formula_0">a ida</formula><p>• 2, the category with a two elements and a single arrow between these elements a b ida f id b</p><p>• : the category with two elements and two parallel arrows between these elements:</p><formula xml:id="formula_1">a b ida id b</formula><p>From now on we will sometimes omit the identity arrows when drawing categories.</p><p>• Another example of a category is a monoid category, which is a specific kind of category with a single object. Indeed, it is a group structure without requirement of inverse elements. It is also called a semi-group with unit)</p><p>This corresponds to a category C(M ) where:</p><p>-There is a single object (for which we simply write M ) -There are arrows m : M → M for each element m ∈ M . -Composition is given by the binary operation of the monoid: m <ref type="bibr" target="#b2">1</ref> • m 2 ≡ m 1 · m 2 . -The identity arrow id M is equal to e, the unit of the monoid.</p><p>• We can also consider natural numbers N &gt;0 , with arrows going from each number to its multiples. • A partially ordered set (poset): a binary relation ≤ over a set S s.t. for a, b, c ∈ S:</p><formula xml:id="formula_2">-a ≤ a -a ≤ b, b ≤ a =⇒ a = b -a ≤ b, b ≤ c =⇒ a ≤ c</formula><p>also corresponds to a category.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Functors</head><p>A functor is a map between categories. This means it sends objects to objects, and arrows to arrows.</p><p>Definition: A functor T between categories C and D consists of two functions (both denoted simply by T ):</p><p>• An object function that maps objects a ∈ C: a → T a ∈ D • An arrow function that assigns to each arrow f : a → b in C an arrow T f : T a → T b in D, such that:</p><formula xml:id="formula_3">T (id a ) = id T a , T (g • f ) = T g • T f.</formula><p>A functor is a very powerful concept, since it allows you to translate between different branches of mathematics! They also play an important role in functional programming. Where among many other things, they are useful for defining the container types or more generally type constructors.</p><p>Functors can be composed, and this allows one to define a category of categories 1 Cat, where the arrows are functors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Examples of functors</head><p>• The identity functor: id C : C → C is defined as:</p><formula xml:id="formula_4">id C : a → a f → f • The constant functor ∆ d : C → D for fixed d ∈ D:</formula><formula xml:id="formula_5">∆ d : a → d f → id d</formula><p>• The power-set functor: P : Set → Set sends subsets to their image under maps. Let A, B ∈ Set, f : A → B and S ⊂ A: PA = P(A), Pf : P(A) → P(B), S → f (S)</p><p>• From many categories representing 'sets with added structure' (groups, vector spaces, rings, topological spaces, . . . ) there is a forgetful functor going to Set, where objects are sent to their underlying sets.</p><p>As an additional example, there is also a forgetful functor F : Cat → Graph, sending each category to the graph defined by its objects and arrows.</p><p>• Dual-set functor * : Vect → Vect</p><formula xml:id="formula_6">: W → W * : (f : V → W ) → (f * : W * → V * )</formula><p>This is an example of a contravariant functor (a functor from Vect to Vect op , the category with reversed arrows and composition rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Special objects, arrows and functors</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Special objects</head><p>For objects, we distuinguish two special kinds: Definition 1.3. An object x ∈ C is terminal if for all a ∈ C there is exactly one arrow a → x. Similarly, it is initial if there is exactly one arrow x → a to all objects.</p><formula xml:id="formula_7">a i t b</formula><p>Here, i is initial, and t is terminal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Special arrows</head><p>There are a number of special kind of arrows: Definition 1.4. An arrow f : a → b ∈ C is a monomorphism (or simply mono), if for all objects x and all arrows g, h : x → a and g = h we have:</p><formula xml:id="formula_8">f • g = f • h.</formula><p>To put this into perspective, we show that in the category Set monomorphisms correspond to injective functions; Theorem 1.5. In Set a map f is mono if and only if it is an injection.</p><p>Proof. Let f : A → B. Suppose f is injective, and let g, h : X → A. If g = h, then g(x) = h(x) for some x. But since f is injective, we have f (g(x)) = f (h(x)), and hence h • f = h • f , thus f is mono.</p><p>For the contrary, suppose f is mono. Let { * } be the set with a single element.</p><p>Then for x ∈ A we have an arrow { * } → A corresponding to the constant functioñfunctioñ x( * ) = x, then f • ˜ x( * ) = f (x). Let x = y. Since f is mono, (f • ˜ x)( * ) = (f • ˜ y)( * ), and hence f (x) = f (y), thus f is an injection.</p><p>There is also an generalization of the notion of surjections. Definition 1.6. An arrow f : a → b ∈ C is a epimorphism (or simply epi), if for all objects x and all arrows g, h : b → x we have:</p><formula xml:id="formula_9">g • f = h • f =⇒ g = h.</formula><p>Finally, we introduce the notion of an 'invertible arrow'. In set, epi and mono imply iso. This however does not hold for general categories!</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Special functors</head><p>Lastly, we turn our attention to special kinds of functors. For this we first introduce the notion of a hom-set of a and b, the set 2 of all arrows from a to b:</p><p>Hom C (a, b) = {f ∈ C | f : a → b}. When after applying F an arrow F f or an object F a has a certain property(i.e. being initial, terminal or epi, mono), it is implied that f (or a) had this property, then we say the F reflects the property.</p><p>This allows for statements such as this: Theorem 1.9. A faithful functor reflects epis and monos.</p><p>Proof. As an example we will prove it for a F f that is mono. Let f : a → b such that F f is mono, and let h, g : x → a such that h = g.</p><formula xml:id="formula_10">x a b F x F a F b F g h F f F F g F h F f</formula><p>Since g = h and F is faithful, we have F g = F h. This implies, because F f is mono, that F f • F g = F f • F h, and since F is a functor we have F (f • g) = F (f • h), implying f • g = f • h, and hence f is mono. Where the composition of the rhs is simply composition in D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Natural transformations</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Exercises</head><p>Exercise 1.1. Let C be a category, and let f : a → b in C be iso with inverse g : b → a.</p><p>Show that g is unique, i.e. for any g that is an inverse of f we have g = g. Exercise 1.5. Let F, G : C → D be functors, and let µ : F ⇒ G. Show that µ is an isomorphism (in the category of functors between C and D) if and only if its components are isomorphisms (in D) for all a ∈ C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.6">References</head><p>• Chapter 2</p><p>Types and functions: a category for programmers ""A monad is a monoid in the category of endofunctors, what's the problem?"</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>James Iry jokes about Haskell in his blog post A Brief, Incomplete, and Mostly Wrong History of Programming Languages</head><p>To establish a link between functional programming and category theory, we need to find a category that is applicable. Observe that a type in a programming language, corresponds to a set in mathematics. Indeed, the type int in C based languages, corresponds to some finite set of numbers, the type char to a set of letters like 'a', 'z' and '$', and the type bool is a set of two elements (true and false). This category, the category of types, turns out to be a very fruitful way to look at programming.</p><p>Why do we want to look at types? Programming safety and correctness. In this part we will hopefully give an idea of how category theory applies to programming, but we will not go into to much detail yet, this is saved for later parts.</p><p>We will take as our model for the category of Haskell types (Hask) the category Set.</p><p>Recall that the elements of Set are sets, and the arrows correspond to maps. There is a major issue to address here: Mathematical maps and functions in a computer program are not identical (bottom value ⊥). We may come back to this, but for now we consider Set and Hask as the same category.</p><p>In Haskell, we can express that an object has a certain type:</p><p>a :: Integer</p><p>In C++ we would write:</p><formula xml:id="formula_11">int a;</formula><p>To define a function f : A → B from type A to type B in Haskell:</p><p>f :: A -&gt; B</p><p>To compose:</p><formula xml:id="formula_12">g :: B -&gt; C h = f . g</formula><p>This means that h is a function h :: A -&gt; C! Note how easy it is to compose functions in Haskell. Compare how this would be in C++, if we were to take two polymorphic functions in C++ and compose them:</p><formula xml:id="formula_13">template &lt;typename F, typename G&gt; auto operator * (G g, F f) { return [&amp;](auto x) { return g(f(x)); }; } int main() { auto f = [](int x) -&gt; float { return ...; }; auto g = [](float y) -&gt; int { return ...; };</formula><p>std::cout &lt;&lt; (g * f)(5) &lt;&lt; "\n"; } We need some additional operations to truly turn it into a category. It is easy to define the identity arrow in Haskell (at once for all types):</p><p>id :: A -&gt; A id a = a in fact, this is part of the core standard library of Haskell (the Prelude) that gets loaded by default. Ignoring reference types and e.g. const specifiers, we can write in C++:</p><formula xml:id="formula_14">template &lt;typename T&gt; T id(T x) { return x; }</formula><p>There is one issue we have glared over; in mathematics all functions are pure: they will always give the same output for the same input. This is not always the case for computer programs, using IO functions, returning the current date, using a global variable are all examples of impure operations that are common in programming. In Haskell, all functions are pure, and this is a requirement that allows us to make the mapping to the category Set. The mechanism that allows Haskell programs to still do useful things is powered by monads, which we will discuss later.</p><p>Although many of the things we will consider can apply to other languages (such as Python and C++), there is a strong reason why people consider often consider Haskell as an example in the context of category theory and programming; it origi- nates in academia and therefore takes care to model the language more accurately. For example, since we take as our model the category Set, there should be a type that corresponds to the empty set ∅. In C / C++, the obvious candidate would be void for this set, but consider a function definition:</p><formula xml:id="formula_15">void f() { ... };</formula><p>This can be seen as a function from void -&gt; void. We can call this function using f(), but what does it mean to call a function? We always invoke a function for an argument, so void actually corresponds to the set with a single element! Note that C functions that return void either do nothing useful (i.e. discard their arguments), or are impure. Indeed, even using a pointer argument to return a value indirectly modifies a 'global state'! In Haskell, the type corresponding to the singleton set (and its single value) is denoted with (). Meaning that if we have a function:</p><p>f :: () -&gt; Int we can invoke it as f()! Instead, the type Void corresponds to the empty set, and there can never be a value of this type. There is even a (unique) polymorphic (in the return type!) function that takes Void added to the prelude:</p><p>absurd :: Void -&gt; a You may be tempted to discard the type Void as something that is only used by academics to make the type system 'complete', but there are a number of legitimate uses for Void. An example is Continuation passing style, or CPS, where functions do not return a value, but pass control over to another function:</p><formula xml:id="formula_16">type Continuation a = a -&gt; Void</formula><p>In other words, a continuation is a function that never returns, which can be used to manipulate control flows (in a type-safe manner).</p><p>Recall that an initial object has exactly one arrow to each other object, and a terminal object has exactly one arrow coming from each other object. These objects are unique up to isomorphism. In the category of types, they correspond to Void and () respectively.</p><p>To summarize this introduction, in the category of 'computer programs', types are objects, and pure functions between these types are arrows. Next, we consider how we can apply some of the concepts we have seen, such as functors and natural transformations, to this category.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Containers as functors</head><p>When we consider functors in the category of types, the first question is 'to what category?'. Here, we will almost exclusively talk about functors from Hask to itself, i.e. endofunctors.</p><p>Endofunctors in Hask map types to types, and functions to functions. There are many examples of functors in programming. Let us first consider the concept of lists of objects, i.e. arrays or vectors. In C++ a list would be written as: or in Python we would have;</p><p>&gt;&gt;&gt; import numpy as np &gt;&gt;&gt; a = np.array( <ref type="bibr" target="#b2">[1,</ref><ref type="bibr" target="#b4">2,</ref><ref type="bibr">3]</ref>, dtype='int') &gt;&gt;&gt; type(a) &lt;class 'numpy.ndarray'&gt; &gt;&gt;&gt; a.dtype dtype <ref type="bibr">('int64')</ref> Note here that the true type of the numpy array is hidden inside the object, meaning its the responsiblity of the program to make sure that the types of operations match! The reason that we consider numpy arrays is that normal 'lists' in Python are actually tuples, which we will discuss when we talk about products and coproducts.</p><p>Let us consider the mathematical way of expressing this: Example 2.1. Lists of some type are more generally called words over some al- phabet (i.e. a set) X, and we denote the set of all finite words of elements 1 in X as X * . Elements in X * look like:</p><formula xml:id="formula_17">(x 1 , x 2 , x 3 ) (x 1 ) ()</formula><p>These are all examples of words in X (where the last example corresponds to the empty word). If we want to construct a word functor T , then T would then have the signature:</p><formula xml:id="formula_18">T : X → X * : (f : X → Y ) → (T f : X * → Y * )</formula><p>For this second option, we have an obvious candidate for the precise function, let f : X → Y be some map, then T f maps a word in X gets to a word in Y in the following way:</p><formula xml:id="formula_19">T f (x 1 , x 2 , x 3 , ...x n ) = (f (x 1 ), f (x 2 ), f (x 3 ), . . . , f (x n )).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Type classes and type constructors</head><p>We will express this idea in Haskell, but before we can do this we first have to consider type classes and -constructors. A type constructor is a 'function' (on types, not an arrow) that creates a type out of a type. A type constructor can have multiple value constructors, and these constructors can be differentiated between using something called pattern matching which we will see later. As an example, consider Bool. Here, we define the type constructor Bool as the resulting type corresponding to the value given by the value constructors True and False, which both are nullary con- structors (that take no argument as types!). Normally however, type constructors take one or multiple types for their value constructors:</p><formula xml:id="formula_20">data Either a b = Left a | Right b</formula><p>Here, the type constructor either hold either a value of type a or of type b, corre- sponding to the value constructors Left and Right. We will revisit this idea (and Either) when talk about products and coproducts.</p><p>A type class is a common interface for types. It defines a family of types that support the same operations. For example, a type class for objects that support equality is defined as:</p><p>class Eq a where (==) :: a -&gt; a -&gt; Bool</p><p>If we want to express the concept 2 functor using a typeclass, we have to state that it can send types to types, and that it sends functions between two types to functions with the appropriate signature, i.e.:</p><p>class Functor F where fmap ::</p><formula xml:id="formula_21">(a -&gt; b) -&gt; F a -&gt; F b</formula><p>This says that F is a functor, if there is a function fmap that takes a function f :: a -&gt; b and maps it to a function fmap f :: F a -&gt; F b. Note that we do not explicitely have to state that F sends types to types, because this can be induced from the fact that we use F a where the compiler expects a type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The List functor</head><p>The list functor in Haskell is denoted with [], and a list of type a is denoted <ref type="bibr">[a]</ref> (which is syntactic sugar, normally the type would be [] a).</p><p>Let us try to define this functor from the ground up. If we would write List instead of [], then first we have to define what a list is. We can define this as follows:</p><formula xml:id="formula_22">data List a = Nil | Cons a (List a)</formula><p>Here the type constructor has two possible ways of constructing (partitioning the possible values of the type): a list of as is either empty (corresponding to the constructor Nil), or that it is the concatenation (corresponding to the constructor Cons) of an object of type a with another list of as. Note that this is a recursive definition!</p><p>Next we define the fmap corresponding to our List functor (i.e. how it maps functions). The corresponding definition to the map described for the word functor is:</p><p>instance Functor List where</p><formula xml:id="formula_23">fmap _ Nil = Nil fmap f (Cons x t) = Cons (f x) (fmap f t)</formula><p>If a list is empty, then we get the empty set, otherwise we map the indivual values in the list recursively using the given f. In C++ this fmap functor roughly corresponds to std::transform, while for Python the closest thing would be the map function. With these two definitions, List is a functor! We could check the that it satisfies the requirements.</p><p>As mentioned, List is implemented in the standard library as [], and Cons is written as :, while the empty list is written also as []. This allows you to write:</p><formula xml:id="formula_24">x = 1 : 2 : [] --this results in`[in`[1, 2] :: [Int]`!</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Maybe functor</head><p>As a simpler example, consider a type that either has no value or it has a value corresponding to some type a. In Haskell, this is called Maybe, while in C++ this is called std::optional, in Python the same idea could be achieved using:</p><formula xml:id="formula_25">def fn(a): if (a &gt;= 0) return sqrt(a) return None</formula><p>This function returns None (corresponding to 'no value') if we provide 'invalid input'. This functor can be defined as:</p><formula xml:id="formula_26">data Maybe = Nothing | Just a</formula><p>And to turn it into a functor, we define fmap: instance Functor Maybe where fmap _ Nothing = Nothing fmap f (Just a) = Just (f a)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Polymorphic functions as natural transformations</head><p>Now that we view type constructors as functors, we can consider natural transfor- mations between type constructors. If we let a be a type, then a natural transfor- mation alpha would be something that maps between F a and G a, where F and G are type constructors:</p><formula xml:id="formula_27">alpha :: F a -&gt; G a</formula><p>Note that implicitely we talk about the component of alpha at a, since this function is polymorphic the right component gets picked by the compiler. For example, say we have a list <ref type="bibr">[a]</ref>, and we want to obtain the first element of this list. If the list is empty, then there is no such element, otherwise we obtain an a; i.e. the result is a Here, we have a natural transformation between the List and the Maybe functor!</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Parametric polymorphism and ad-hoc polymorphism</head><p>In C++, a template does not have to be defined for all types, i.e. we can write:</p><p>template &lt;typename T&gt; T f(T a);</p><formula xml:id="formula_28">template &lt;&gt; int f(int a) { return 2 * a; } template &lt;&gt; double f(double a) { return 2.0 * a; }</formula><p>Here, e.g. f&lt;int&gt;(1) would yield 2, while f&lt;char&gt;('a') would result in a compi- lation error.</p><p>In Haskell, this is not allowed, polymorphic functions must work for all types, this is called parametric polymorphism. Specializing function definitions is done using type classes <ref type="bibr">3</ref> . This has an important consequence (or perhaps, it is the underlying reason): a parametric polymorphic function satisfies automatically the naturality conditions.</p><p>The corresponding diagram is:</p><formula xml:id="formula_29">F a G a F b G b alpha fmap f :: F a -&gt; F b fmap f :: G a -&gt; G b alpha</formula><p>Here the left fmap works for F, while the right fmap corresponds to G, and the top alpha is implicitely the component at a, while the bottom one is the component at b. What would have to show, is that automatically fmap f . alpha = alpha . fmap f</p><p>This can be shown in a very general context, and it has to do with the fact that the 'bodies'for f, fmap and alpha are the same for all types. We will show this in an upcoming part when we discuss free theorems.</p><p>Let us revisit our head :: [a] -&gt; Maybe a example, and consider the naturality condition here. It says that:</p><formula xml:id="formula_30">fmap f . head = head . fmap f</formula><p>Here, the fmap on the lhs corresonds to the Maybe functor, while on the rhs it corresponds to the [] functor. The lhs can b e read like this; take the first element of the list, then apply f on it. The rhs can be read as "apply the function f to the enitre list, then take the first element". The result is the same; the funtion f applied to the head of the list (if any). But for the rhs we apply the function f for each element in the list, while on the lhs we only apply it to the head. Because of the constraint on polymorphic function, the compiler knows that the result is equal and can choose which one to use!</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">References</head><p>• 1.2, 1.7 of the 'Category Theory for Programmers' blog by Bartosz Milewski</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Chapter 3</head><p>Products, coproducts and algebraic data types</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Duality and products of objects</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Duality</head><p>For any category, we can define the category with all arrows (and composition) reversed.</p><p>Definition 3.1. The opposite category C op of a category C is the category with:</p><p>• The same objects as C.</p><p>• For all arrows f : a → b in C, there is an arrow f op : b → a</p><p>• The composition of f op : a → b and g op : b → c is given by:</p><formula xml:id="formula_31">g op • f op = (f • g) op</formula><p>The opposite category is very useful, because many concepts defined in the original category have 'dual notions' in the opposite category. Clearly, for example, an initial object in C is a terminal object in C op . Similarly, an arrow that is mono in C is epi in C op . This is called duality, and provides so-called 'co-' notions of constructs, as well as 'co-' versions of theorems.</p><p>Whenever defining something it always make sense to see what this means in the opposite category, giving you a lot of free information. For example, we showed that faithful functors reflects mono's. Looking at the dual category, we immediately have that it also reflects epi's!</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Products</head><p>Initial objects and terminal objects have a universal property, they are defined by the property that e.g. all other objects have a unique morphism to the object. A more involved example of such a universal property is the notion of a product of objects.</p><p>The categorical product is a unifying definition for many 'products' encountered in mathematics, such as the cartesian product, product group, products of topological spaces, and so on. In this case, the (unique) arrows q are what gives the product a universal mapping property. If a product exists, it is unique op to unique isomorphism.</p><p>We say that the functions f and g factors through a × b, or that a × b factorizes f and g. The reason for this name is clear when making the analogy with numbers.</p><p>Consider:</p><formula xml:id="formula_32">f = p 1 • q, g = p 2 • q.</formula><p>For an example with numbers:</p><formula xml:id="formula_33">2 8 8 16 ×4 ×8 ×4 ×1 ×2 4 = 2 × 2, 8 = 4 × 2.</formula><p>This seems to indicate that in 'some category related to numbers' (in fact, precisely the category of natural numbers with arrows to their multiples, that we gave as an example in the first chapter), the product would correspond to the gcd! Example 3.3. Let us consider the product of objects in Set. Consider two sets A, B.</p><p>We have a clear candidate for a product; the cartesian product A × B. Given any element (or pair) (a, b) ∈ A × B, the projections p 1 , p 2 send it to a and b respectively. Is this indeed a product?</p><p>Let V be any other set, with arrows (functions) f to A and g to B.</p><p>Can we construct a (unique) arrow q to A × B?</p><formula xml:id="formula_34">V A × B A B f g q p 1 p 2</formula><p>Consider any element v ∈ V . It gets mapped to f (v) ∈ A, and g(v) ∈ B. Let</p><formula xml:id="formula_35">q : v → (f (v), g(v)), then (p 1 • f )(v) = f (v)</formula><p>, and thus</p><formula xml:id="formula_36">p 1 • f = f . Similarly p 2 • g = g.</formula><p>Indeed, we have constructed an arrow that makes the above diagram commute. It is also clear that this is the only arrow that satisfies this, so we conclude that A × B is the product of A and B in the category Set. Another example of a product of sets would be B × A, which is cannonically isomorphic to A × B (the isomorphism corresponds to 'swapping' the elements, which is its own inverse).</p><p>For a completely different example, we consider the category corresponding to a poset.</p><p>Example 3.4. Let us consider the product of objects in the category corresponding to some poset P . Consider two elements x, y ∈ P . A product z ≡ x × y would be equiped with two arrows z → x and z → y, which means z ≤ x and z ≤ y. Furthermore, for any element w with arrows to x, y (i.e. w ≤ x and w ≤ y), there has to be an arrow q : w → z (i.e. w ≤ z). This is the same as saying that, in addition to z ≤ x and z ≤ y, we have for all elements w of the poset:</p><formula xml:id="formula_37">w ≤ x and w ≤ y =⇒ w ≤ z</formula><p>This means that z is the "largest element that is smaller or equal to x and y", also called the infimum of x and y.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Coproducts</head><p>Let us revisit the idea of duality. What would be the dual notion of the product? Let us take the product diagram, and reverse the arrows:</p><formula xml:id="formula_38">c a + b a b q f p 1 g p 2</formula><p>This already very suggestives, we have arrows going from objects a, b into the coproduct (written 'a+b', we will see why soon), and from this coproduct arrows going to arbitrary target objects c. The arrows a → a + b and b → a + b already look kind of like an inclusion. Let us see what happens when we apply duality to the product definition, and change some names. Note that this is precisely the definition of the product, with all arrows reversed and the projections renamed to i 1 and i 2 .</p><p>Because of the properties that we will show discover, the coproduct is also called the sum. Note that this dual notion is fundamentally different. Let us see what it means for the category Set: Example 3.6. Consider two sets A, B. When looking at the diagram for the coprod- uct, we see that we need to find some kind of set in which elements of A and B are represented but completely independent; since c is now the target of the functions we want to factor through a + b.</p><p>This describes the union of A and B, but only if the two are disjoint since in the intersection of A and B we would not know whether q should represent f or g. This is easily solved by looking at the disjoint union, which has a nice representation: Consider any element a ∈ A. It gets mapped to f (a) ∈ V , and to i 1 (a) = (a, 0) in A + B. Then we should set q(a, 0) ≡ f (a), and similarly we should set q(b, 1) ≡ g(b). This already defines q uniquely and completely, so we conclude that the disjoint union is indeed the coproduct in the category Set.</p><formula xml:id="formula_39">A + B ≡ {(a, 0) | a ∈ A} ∪ {(b, 1) | b ∈ B}.</formula><p>We note there that the coproduct (and product) of two objects, generalizes also to products of more than 2 objects (by simply adding more maps i 1 , i 2 , i 3 . . .).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Algebraic data types</head><p>Let us apply the product (and coproduct) concepts to the category of types. Since we already saw what these constructs mean for sets, namely the cartesian product and the disjoint union respectively, it should be clear what this means for types.</p><p>Given a type a and a type b, the product corresponds to a pair, written <ref type="bibr">(a, b)</ref> in Haskell. We could implement this ourselves using simply: Here, we give the unique value constructor the same name as its type constructor. In C this would correspond roughly to a struct (more specifically a POD data type), although a Record in Haskell corresponds more precisely to a struct. Note for this to make sense, the product type should (and is) be defined for more than 2 elements.</p><formula xml:id="formula_40">data</formula><p>In C++ this is known as a std::pair (or a std::tuple for n-ary products). How- ever, its implementation (and also usage) is awkward and convoluted. Functional programming (and product/coproduct types) is not yet a first-class citizen in C++.</p><p>The coproduct (or sum type corresponds to a value that has either type a, or type b. This is implemented as the Either data type:</p><formula xml:id="formula_41">data Either a b = Left a | Right b</formula><p>Here, the two value constructors take an element of type a, or an element of type b respectively. In C and C++ this would correspond roughly to a union 1 , except that it is tagged.</p><p>A sum type means choosing an alternative between types, while the product type is a combination of the types. Let us look at some more examples:</p><p>• In C, an enum represents a fixed number of alternative constants. In Haskell, this would correspond to the sum type of multiple 0-ary value constructors (implicitely the finite sum type of the type () with itself):</p><formula xml:id="formula_42">data Enum = One | Two | Three</formula><p>• A node of a binary tree of type a has a sum type: it is either () (representing a leaf), or it is the product type of:</p><p>-Tree on the left -a for the value of the node -Tree on the right or in Haskell:</p><p>data Tree a = Leaf | Node (Tree a) a (Tree a)</p><p>• Using the product and sum types, we can turn the type system into a semi- ring, where we define:</p><formula xml:id="formula_43">-0 = Void -1 = () -a + b = Either a b = Left a | Right b -a × b = (a, b)</formula><p>Let us check that 0 really works as 0. What happens when we add Void to a type:</p><formula xml:id="formula_44">Either a Void = Left a | Right Void</formula><p>We can never get a value for void, so the only thing we can do is to construct Either a Void with a value of type a, which means:</p><formula xml:id="formula_45">a + 0 = a.</formula><p>Similarly, if we have a product with Void, we can never instantiate a pair (because there is no value for Void), so the corresponding product type is again Void:</p><formula xml:id="formula_46">a × 0 = 0.</formula><p>Although this is all a bit of a stretch, this analogy has some interesting proper- ties, and we can do some real algebra with our types and try to interpret the results. Consider again the list type:</p><p>List a = Empty | Cons a (List a)</p><p>In our 'semi-ring', writing x for List a, this would look like the expression:</p><formula xml:id="formula_47">x = 1 + a × x</formula><p>This is unsolvable, but we can try to iteratively substitute x into the right hand side:</p><formula xml:id="formula_48">x = 1 + a × (1 + ax) = 1 + a + a 2 x = 1 + a + a 2 (1 + ax) = 1 + a + a 2 + a 3 (1 + ax) = . . .</formula><p>Which can be read as 'a list is either empty, or it has one element of type a, or it has two elements of type a, etc. Although this is mostly an entertaining (and, depending on your view, an overly complicated) way of looking at types, a similar correspondence from types to logical operations forms the basis of the Curry-Howard isomorphism that connects type theory to logic in a very fundamental way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Bi-functors</head><p>Definition 3.7. Given two categories C, D their product category C × D is given by:</p><p>• The objects are pairs (c, d) where c ∈ C and d ∈ D.</p><p>• The arrows are pairs of arrows, (f, g) :</p><formula xml:id="formula_49">(c, d) → (c , d ) for f : c → c in C and g : d → d in D.</formula><p>• The identity arrow for (c, d) is the pair (id c , id d ).</p><p>• Composition of arrows happens per component, i.e. when f, g in C and h, k ∈ D:</p><formula xml:id="formula_50">(f, h) • (g, k) ≡ (f • g, h • k)</formula><p>Note that alternatively we could define this as the product of objects in the category Cat.</p><p>This brings us to the concept of a bifunctor, which can be seen as a 'functor of two arguments'. Definition 3.8. Let C, D, E be categories. A bifunctor is a functor:</p><formula xml:id="formula_51">F : C × D → E.</formula><p>We now ask ourselves how bifunctors relate to functors. This is summarized in the following proposition, where we denote pairs as c, d ∈ C × D:</p><formula xml:id="formula_52">Proposition 3.9. Let F : C × D → E be a bifunctor. Then:</formula><formula xml:id="formula_53">F c, −− ≡ G c : D → E, d → F c, d, (g : d → d ) → F id c , g F −, d ≡ H d : C → E, c → F c, d, (f : c → c ) → F f, id d</formula><p>are functors for all c ∈ C and d ∈ D respectively, and furthermore they satisfy:</p><formula xml:id="formula_54">G c d = H d c (3.1) G c g • H d f = H d f • G c g (3.2)</formula><p>for all c, c ∈ C and d, d ∈ D. Conversely, let G c , H d be family of functors so that (3.1) and (3.2) hold, then:</p><formula xml:id="formula_55">˜ F : C × D → E, c, d → G c d, f, g → H d f • G c g</formula><p>is a bifunctor, and satisfies˜Fsatisfies˜ satisfies˜F c, −− = G c and˜Fand˜</p><formula xml:id="formula_56">and˜F −, d = H d .</formula><p>Proof. Let us first show that we can construct the functors G c and H d from a bifunc- tor F . We show that G c is a functor, H d follows similarly.</p><formula xml:id="formula_57">G c (id d ) = F id c , id d = id F c,d G c (g • g ) = F id c , g • g = F (id c , g • •id c , g ) = F id c , g • F id c , g = G c g • G c g</formula><p>and clearly the mapped arrows have the correct (co)domains, hence G c is a functor for all c. Showing (3.1) is simply, by definition both sides are equal to F c, d. To show (3.2) we compute:</p><formula xml:id="formula_58">G c g • H d f = F id c , g • F f, id d = F (id c , g • •f, id d ) = F (f, g) = F (f, id d • •id c , g) = F f, id d • F id c , g = H d f • G c g</formula><p>To show the converse statement, we compute:</p><formula xml:id="formula_59">F id c , id d = G c id d • H d id c = id Gcd • id H d c = id F c,d • id F c,d = id F c,d F (f, g • •f , g ) = F f • f , g • g = G c g • G c g • H d f • H d f = G c g • H d f • G c g • H d f = F f, g • F f , g</formula><p>In Haskell the bifunctor is implemented as a type class, which is implemented in the standard library as follows: Here you see a circular definition. This means it is enough to either provide the bimap, or the first and second functions, powered by Proposition 3.9.</p><p>Example 3.10. Whenever you have a category C where the product of two objects exists for all pairs of objects, then this gives rise to a bifunctor:</p><formula xml:id="formula_60">× : C × C → C : (a, b) → a × b : (f : a → a , g : b → b ) → (f × g : a × b → a × b )</formula><p>where we find f × g by looking at the diagram:</p><formula xml:id="formula_61">a a × b b a a × b b f f ×g p 1 p 2 g p 1 p 2</formula><p>By definition of the product a × b , we have that for any object c that has arrows to a and b , there should be a unique arrow c → a × b . Note that f • p 1 and g • p 2 are arrows from a × b to a and b respectively, meaning that we can set f × g to the unique arrow going between a × b and a × b .</p><p>By duality, there is also a bifunctor corresponding to the coproduct if it is defined everywhere. What would these two examples mean in Haskell? The product is the 'pair functor' (,), and the coproduct is the sum type Either. These are examples of type constructors (or algebraic data types, as we have seen). Since functors compose, we could ask ourselves: "Are all algebraic data types functors?". The answer is positive, and this allows the Haskell language to derive an implementation of fmap for all ADTs!</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Exercises</head><p>Exercise 3.1. In the category Vect, show that the product corresponds to the direct sum.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">References</head><p>• Chapter 4</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Yoneda Lemma</head><p>The Yoneda Lemma relates a category C with the functors from C to Set. Before we can introduce the lemma's we will introduce a number of concepts; first we intro- duce a class of functors called hom-functors, we introduce the notion of representable functors, we will discuss the Yoneda embedding and finally we will move on to the Yoneda Lemma; one of the important tools in category theory</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Hom-functors</head><p>The hom-functor for some fixed object c, is a functor that sends any object a to the hom-set Hom(c, a). It is clear that for each object we get an associated object in Set, but what should this functor do with arrows? We will denote the candidate functor with F = Hom(c, −). Say we have an arrow f : a → b:</p><formula xml:id="formula_62">a Hom(c, a) b Hom(c, b) f F ? F</formula><p>The arrow marked with a question marked is an arrow in Set. Arrows in sets are functions, which we can define by saying what it does on elements. The elements of the hom-sets are arrows in C. Given some element of Hom(c, a), i.e. an arrow in C: g : c → a, we need to obtain an element of Hom(c, b), i.e. an arrow from c → b.</p><p>We have the following picture</p><formula xml:id="formula_63">c a b g F f (g)=?</formula><p>We can go to a from c using g, but then we need a way to get from a to b. We actually have a way to do this, namely the arrow f : a → b that we started with. We need only to compose! This motivates the following definition:</p><p>Definition 4.1. Let C be a category, and let c ∈ C and f : a → b ∈ C. We define the (covariant) hom-functor Hom(c, −) : C → Set as:</p><formula xml:id="formula_64">Hom(c, −)(a) =Hom(c, a) Hom(c, −)(f ) :Hom(c, a) → Hom(c, b), g → f • g</formula><p>Clearly the identity arrow gets mapped to the identity map. To show that composi- tions are preserved, we compute for any arrow h : c → a:</p><formula xml:id="formula_65">Hom(c, −)(g • f )(h) = (g • f ) • h = g • (f • h) = g • (Hom(c, −)(f )(h)) = Hom(c, −)(g) (Hom(c, −)(f )(h)) = (Hom(c, −)(g) • Hom(c, −)(f )) (h)</formula><p>We can also define the contravariant hom-functor: C op → Set by precomposing with f , and we denote it as Hom(−, d).</p><p>Let us introduce a term; functors are called naturally isomorphic if there is a natural transformation between them for which all components are isomorphisms. Hom-functors are such an important class of functors from C → Set, that they motivate the following definition: Definition 4.2. A functor F : C → Set is called representable if it is naturally isomorphic to a hom-functor.</p><p>To simplify the notation in the upcoming sections, we will denote the covariant hom-functor Hom(a, −) = h a and the contravariant hom-functor Hom(−, b) = h b .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Yoneda Embedding</head><p>For any category C the Yoneda embedding is a functor between the opposite category and the category of functors between C and Set. Let us first introduce this target category.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.3.</head><p>Let C and D be two categories, then we define Fun(C, D) as the category with as objects functors C → D, and as arrows natural transformations between these functors. Now, we are ready to describe the Yonedda embedding. Note that because it is a functor between the opposite of C and the category of functors between C and Set, it should take objects to functors, and arrows to natural transformations. For all objects, we have introduced a functor associated to it in the previous section; the hom-functor.</p><formula xml:id="formula_66">a h a b h b f Y Y f Y</formula><p>The natural transformation Y f should have components which are arrows in Set, indexed by objects in C. Let k : d → c (note the reversed order), the corresponding naturality square looks like this:</p><formula xml:id="formula_67">Hom(a, c) Hom(b, c) Hom(a, d) Hom(b, d) (Y f )c h a (k) h b (k) (Y f ) d</formula><p>So the natural components should be maps between hom-sets, and again we can find these maps by composition! This is summarized in the following definition:</p><formula xml:id="formula_68">Definition 4.4 (Yoneda embedding). The Yoneda functor Y : C op → Fun(C, Set), is defined as follows. Let a ∈ C and f : b → c in C. Y a =h a Y f op :h c → h b (Y f op ) a :Hom(c, a) → Hom(b, a) :(g : c → a) → (g • f : b → a) =h a f</formula><p>Note that the component is defined using pre-composition, it is a contravariant hom- functor, whereas the objects Y a are covariant hom-functors, i.e. use post-composition.</p><p>Let us check that Y f is indeed a natural transformation by looking at the naturality square introduced above, let : a → c, and lets trace it through the diagram for some k : c → d and g : b → a:</p><formula xml:id="formula_69">∈ Hom(a, c) Hom(b, c) • g k • ∈ Hom(a, d) Hom(b, d) k • ( • g) = (k • ) • g (Y g op )c h a (k) h b (k) (Y g op ) d</formula><p>In other words, the naturality condition corresponds simply to the associativity in C. We say that Y f is the induced natural transformation of f .</p><p>The reason that the Yoneda functor is of such interest is because of the following:</p><p>Theorem 4.5. The Yoneda functor Y is full and faithful.</p><p>We will prove this in the next section, after we state and prove the Yoneda lemma. Theorem 4.5 has the following corollary:</p><p>Corollary 4.6. Let µ : h a → h b be a natural transformation between hom-functors, then it is given by composition with a unique arrow f : b → a. Furthermore, µ is a (natural) isomorphism if and only if f is an isomorphism.</p><p>This means in particular that if a set-valued functor F is represented by both a and b, then there is an isomorphism a</p><formula xml:id="formula_70">∼ → b.</formula><p>Again, by duality, there exists also a full and faithful functor from C → Fun(C op , Set).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">The Yoneda Lemma</head><p>Corollary 4.6 tells us that any natural transformation between covariant hom- functors h a and h b is given by composition with an arrow in the reverse direction f : b → a. Note that this arrow is an element of h b a = Hom(b, a).</p><p>Less obviously, this result holds also for natural transformations between h a and any other set-valued functor F .</p><p>What would a function between h a and F look like? We see that a component of the natural transformation should take an element from h a b, i.e. an arrow g : a → b, to some element of F b. We can do this by evaluating the lifted arrow F g , which is a map between the sets F a and F b, at a fixed x ∈ F a.</p><p>This gives us an idea for a natural transformation corresponding to an element of F a. We summarize this in the following proposition:</p><p>Proposition 4.7. Let F : C → Set be a functor, and a ∈ C. Any element x ∈ F a induces a natural transformation from h a to F , by evaluating any lifted arrow in x.</p><p>Proof. We have to show that this induces a natural transformation, i.e that the following diagram commutes:</p><formula xml:id="formula_71">h a b F b h a c F c h a f F _(x) F f F _(x)</formula><p>Here we denote:</p><formula xml:id="formula_72">F _(x) : h a b → F b, f → F f (x).</formula><p>To show that the diagram commutes, fix an arrow g : a → b ∈ h a b. If we start taking it along the top side we obtain:</p><formula xml:id="formula_73">F f (F g(x)) = (F f • F g)(x) = F (f • g)(x) = (F _(x))(f • g) = (F _(x))((h a f )(g))</formula><p>which is equal to taking it along the bottom, hence the diagram commutes.</p><p>The Yoneda lemma states that all natural transformations between h a and F are of this form.</p><p>Theorem 4.8 (The Yoneda lemma). Let C be a category, let a ∈ C, and let F : C → Set be a set-valued functor. There is a one-to-one correspondence between elements of F a, and natural transformations:</p><formula xml:id="formula_74">µ : h a ⇒ F.</formula><p>Proof. We already saw that each element of F a induces a natural transformation, so we have a map:</p><formula xml:id="formula_75">Φ : F a → Nat(h a , F ).</formula><p>Here, Nat(h a , F ) denotes the set of natural transformations between h A and F . We now need to show show that Φ has an inverse. Let µ be any natural transformation, then we can obtain an element of F a by looking at the component µ a and let it act on the identity arrow id c ∈ h a a, i.e.:</p><formula xml:id="formula_76">Ψ : µ → µ a (id a ).</formula><p>Now let us show that Φ and Ψ are inverses of each other. First, we compute:</p><formula xml:id="formula_77">Ψ(Φ(x)) = Ψ(F _(x)) = F id a (x) = id F a (x) = x,</formula><p>so Ψ is a left inverse of Φ. To show that it is also a right inverse, we need to show that:</p><formula xml:id="formula_78">Φ(Ψ(µ)) = µ,</formula><p>or in components:</p><formula xml:id="formula_79">Φ(Ψ(µ)) b = µ b .</formula><p>We note that by definition, for any f : a → b in h a b:</p><formula xml:id="formula_80">Φ(Ψ(µ)) b (f ) = (Φ(µ a (id a ))) b (f ) = F f (µ a (id a )).</formula><p>Since µ is a natural transformation we have that the following diagram commutes:</p><formula xml:id="formula_81">h a a F a h a b F b h a f µa F f µ b</formula><p>In particular, consider the element id a ∈ h a a. Tracing this along bottom this gets mapped to µ b (f ), while along the top it gives precisely F f (µ a (id a )), so we have shown that:</p><formula xml:id="formula_82">Φ(Ψ(µ)) b (f ) = F f (µ a (id a )) = µ b (f ).</formula><p>And hence, Ψ is also a right inverse of Φ, and thus Φ is a bijection, as required.</p><p>One can also show, that this correspondence is 'natural' in a ∈ C and F .</p><p>Let us now prove Theorem 4.5.</p><p>proof of Theorem 4.5. By Yoneda's Lemma there is a bijection between the sets:</p><formula xml:id="formula_83">Nat(h b , h a ) h a b = Hom(a, b)</formula><p>for all objects a and b of C, which directly implies that the functor Y is full and faithful.</p><p>Let us recap what we have seen so far. We discussed a special class of set-valued functors called hom-functors. These hom-functors, like hom-sets, relate objects directly with the arrows between them.</p><p>Next we showed that we can embed any category into the category of contravariant set-valued functors of this category, sending objects to their hom-functors. We also showed that this embedding, as a functor, is full and faithful, which suggests that all the information of the category and its objects, is contained in its hom-functors.</p><p>When looking at what this means for the arrows, we noted that in particular any natural transformation between hom-functors is given by composition with arrows of our category.</p><p>To prove this, we stated and proved the Yoneda lemma -which is an important result in its own right. It shows that for an arbitrary set-valued functor, there is a bijection between elements of the set F a and natural transformations from h a to F , All functors in Haskell are set-valued, since that is our category of interest. We first show two simple applications of Yoneda's lemma in mathematics, and next we see some initial applications of the Yoneda lemma to Haskell. In later parts we will see more advanced uses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Examples of applications</head><p>Example 4.9 (Matrix row operations). In linear algebra, row operations can be performed without changing the solutions of the linear system. Examples are row permutations, adding the j-th row to the i-th row, or multiplying a row by a (non- zero) scalar. We will show that these row operations are natural, in the following sense.</p><p>Let C be the category where the objects are natural numbers 1, 2, 3, . . ., and where arrows n → m correspond to m × n matrices. Composition is given by matrix multiplication, indeed if we have arrows:</p><formula xml:id="formula_84">n m k A m×n B k×m</formula><p>then the composite B k×m A m×n = C k×n is an arrow from n to k, as required. Consider contravariant hom-functors h n for this category. The hom-set h n k = Hom(k, n) consists of n × k matrices. To show that row operations can be seen as natural transformations µ : h n ⇒ h n , we fix some k × m matrix B, and look at the following naturality square:</p><formula xml:id="formula_85">h n k h n k h n m h n m µ k hnB hnB µm</formula><p>Considering some n × k matrix A, the naturality condition states:</p><formula xml:id="formula_86">µ(A)B ? = µ(AB).</formula><p>To show this, we observe that for all row transformations we have:</p><formula xml:id="formula_87">µ(A) = A + ˜ A</formula><p>where the rows of˜Aof˜ of˜A are either empty, or are multiples of rows of A, or:</p><formula xml:id="formula_88">µ(A) = A + ΛA.</formula><p>Where Λ is a matrix whose elements Λ ij represent how many times row j should be added to row i. This means we have</p><formula xml:id="formula_89">µ(A)B = (A + ΛA)B = AB + ΛAB = µ(AB).</formula><p>as required. By Corollary 4.6 we have that any natural transformation µ : h n ⇒ h n is given by postcomposition (in this category: left-multiplication) with a unique arrow D : n → n. The Yoneda lemma allows us to identify this arrow; it is equal to: </p><formula xml:id="formula_90">D = µ n (Id n ),</formula><formula xml:id="formula_91">• h • G Y Nat(h•,h•)</formula><p>The arrows on the left (displayed collectively using a dashed arrow), corresponding to the elements of G, get mapped fully and faithfully (by Theorem 4.5) to the natural transformations between h • and itself (natural endomorphisms).</p><p>The natural endomorphisms h • are characterized, by Corollary 4.6, (at the only component G) by left-multiplication of elements G on the set h • • • G set which is the underlying set of G (since it is Hom(•, •)). For each element g ∈ G we obtain an automorphism G set → G set given by h → gh.</p><p>Recall that Aut(G set ) is a group (a permutation group), and note that the collection of automorphisms defined by left multiplication of elements of G is indeed a subgroup of this permutation group. The correspondence between G and the "automorphisms by left-multiplication" is easily seen to be a group isomorphism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Yoneda in Haskell</head><p>We will discuss a hopefully intuitive way of looking at the Yoneda lemma in Haskell, by pinpointing a function with a single evaluation. In later parts we will discuss many more applications of Yoneda to Haskell, in particular when we discuss generalized ADTs and lenses.</p><p>Let us first see how we can translate the relevant tools of Yoneda to Haskell. We have the following concepts:</p><p>• hom-sets: the hom-set of types a and b are the arrows between a and b, i.e. functions of the type (a -&gt; b). Note that this hom-set is again in the category of types.</p><p>• The hom-functor corresponding to a type a should be a functor, i.e. a type constructor, that produces the hom-set (a -&gt; b) when given a type b, for some fixed type a. On functions (b -&gt; c) it should get a function between the hom-sets of a and b, c respectively, i.e.:</p><p>instance Functor (HomFunctor a) where</p><formula xml:id="formula_92">fmap :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c) fmap f g = f . g</formula><p>And indeed, we see that we can simply use composition.</p><p>• Yoneda's lemma says that for any other functor F, we can produce a natural transformation (i.e. polymorphic function in a type b) from the hom-functor for a fixed a by looking at elements of F a.</p><p>Next we look at a simple example of how to apply this final point in Haskell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.1">Reverse engineering machines</head><p>We set F equal to Id, the identity functor, and consider a natural transformation between HomFunctor a and Id, this has the form (at the component b):</p><formula xml:id="formula_93">-- (HomFunctor a) b Id b -- | | machine :: (a -&gt; b) -&gt; b</formula><p>Say we are given any function with this signature, and we want to know how it is implemented. We can actually do this in a single evaluation, using the Yoneda lemma. The Yoneda lemma says precisely that such a machine is given uniquely by any element of Id a = a, i.e. some value of the type a. This makes a lot of sense in this context, since we can be given any b, and the only tool that we have to produce a value for b is to use the function f :: a -&gt; b that is supplied to us. Furthermore, the polymorphic function should behave the same for any type, so it can only be implemented as:</p><formula xml:id="formula_94">machine :: (a -&gt; b) -&gt; b machine f = f x</formula><p>where x is some fixed element of type a. Now, the Yoneda lemma also tells us a way to obtain x, we simply supply f = id:</p><p>x &lt;-machine id --obtain the 'hidden element'</p><p>What if F is not the identity function, but say the List functor. The story actually does not change much, we now have a function with the signature:</p><formula xml:id="formula_95">-- (HomFunctor a) b List b -- | | machine :: (a -&gt; b) -&gt; [b]</formula><p>the Yoneda lemma says that internally, any function of this signature should main- tain a list of the type <ref type="bibr">[a]</ref>, and when given a function f :: a -&gt; b it fmaps this over the internal list to produce a value of the type <ref type="bibr">[b]</ref>. Again, we can get this list by feeding the id function into the machine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.2">Continuation Passing Style</head><p>In programming, there is an equivalence between what is called direct style, where functions return values, and continuation passing style (CPS), where each called func- tion takes an additional argument which is a handler function that does something with the result of the called function.</p><p>Say we have some function and the way it is used is:</p><formula xml:id="formula_96">add _ cps(1, 2, [](auto result) { // ... });</formula><p>In other words, the CPS version of the function does not return a value, but rather passes the result to a handler. We do not bind the result of a function to a value, but rather to the argument of a handler function.</p><p>You may recognize this style of programming from writing concurrent programs, where continuations can be used to deal with values produced in the future by other threads without blocking. Continuations are also often used in UI frameworks, where a handler is used whenever e.g. a button is pressed, or the value of a slider has changed.</p><p>This CPS passing style can also be used to implement exceptions. Say we have a function that can throw:</p><formula xml:id="formula_97">void can _ throw(F raise, G cont) { // ... }</formula><p>Here, the idea is that raise gets called if an error occurs, while cont gets called when a result has been computed succesfully. What is also interesting is that CPS can be used to implement control flow. For example, the called function can call cont multiple times (loops), or only conditionally.</p><p>Let us show that the continuation passing transform (CPT), i.e. going from direct style to CPS, is nothing more then the Yoneda embedding. Say we have a function:</p><formula xml:id="formula_98">f :: a -&gt; b</formula><p>Let us remind ourselves that the Yoneda embedding takes such an arrow, and produces a map (Y f ) c = Hom(c, b) → Hom(c, a) for all c ∈ C. In Haskell, this embedding could be implemented like this:</p><formula xml:id="formula_99">yoneda :: forall x. (a -&gt; b) -&gt; (b -&gt; x) -&gt; (a -&gt; x) yoneda f = \k -&gt; k . f</formula><p>Going the other way around is easy, we simply pass id as our continuation k.</p><p>We will revisit continuations when we discuss monads.</p><p>• Chapter 5</p><p>Cartesian closed categories and λ-calculus</p><p>In Haskell, functions that take two arguments can be written as:</p><formula xml:id="formula_100">--1) idiomatic haskell f :: a -&gt; b -&gt; c --2) more conventional style f :: (a, b) -&gt; c</formula><p>the first style can be read as "for any fixed value x of type a, you are given a function b -&gt; c which sends y to f(x, y)". In this part we will discuss why we are allowed to do this, and see the theory that underpins this. The process of converting the second to the first style is called currying (the reverse is called uncurrying) and can be described in the context of category theory.</p><p>In the language of category theory, we are trying to show the equivalence between arrows of the form a × b → c and arrows of the form</p><formula xml:id="formula_101">a → [b → c], where [b → c]</formula><p>is some 'function object'. We will first state what it means to curry a function between sets.</p><p>Definition 5.1. Let A, B, C be sets. We define [A → B] to be the set of functions between A and B. Given a function of two variables:</p><formula xml:id="formula_102">f : A × B → C,</formula><p>we have a function:</p><formula xml:id="formula_103">λf : A → [B → C],</formula><p>defined by λf (a)(b) = f (a, b). We say that λf is the curried version of f , and going from f to λf is called currying.</p><p>Going the other way around is called uncurrying. Let</p><formula xml:id="formula_104">g : A → [B → C],</formula><p>be a function, then we can define λ −1 g :</p><formula xml:id="formula_105">A × B → C by setting λ −1 g(a, b) = g(a)(b).</formula><p>In other words, we have an isomorphism λ between the hom-sets:</p><formula xml:id="formula_106">Hom Set (A × B, C) Hom Set (A, [B → C]).</formula><p>We are now ready to discuss this process more generally, but for this we need to specify what properties our category should have in order for this to work. </p><formula xml:id="formula_107">[b → c] × b a × b c eval b c λf ×id b f</formula><p>Here, the product of arrows f × g is as given in Example 3.10.</p><p>Wherever possible, we will denote eval a b simply as eval. Another common notation for the exponential <ref type="bibr">[a → b]</ref> is b a .</p><p>Note that the commutative diagram that shows up in the definition directly implies that we indeed have a bijection of hom-sets (i.e. it makes sense to curry). That is to say, let C be a CCC:</p><formula xml:id="formula_108">Hom C (a × b, c) Hom C (a, [b → c])</formula><p>are isomorphic, by sending a f : a × b → c using:</p><formula xml:id="formula_109">λ : f → λf,</formula><p>and vice versa:</p><formula xml:id="formula_110">λ −1 g = eval c b • (g × id b )</formula><p>. which is an isomorphism by the commutativity of the diagram and the uniqueness of λf .</p><p>To prove that curried and uncurried version of binary functions are actually equiva- lent we would have to show something stronger, that there is an arrow between</p><formula xml:id="formula_111">[a × b → c] → [a → [b → c]]</formula><p>that is iso, but for this we some more complicated machinery which for now would be too big of a diversion.</p><p>One can show also show that exponentials are unique up to unique isomorphism, but this also requires some machinery that we have not yet developed. We may revisit this when when we get to discuss adjunctions.</p><p>We have already seen that Set is a CCC. Before we give some additional proper- ties of CCCs and the exponential objects in them, let us look at some additional examples of CCCs:</p><p>Example 5.3 (Boolean algebras as CCCs).</p><p>Definition 5.4. A Boolean algebra is a partially ordered set B such that:</p><p>• For all x, y ∈ B, there exists an infimum x ∧ y and a supremum x ∨ y.</p><p>• For all x, y, z we have a distributive property:</p><formula xml:id="formula_112">x ∧ (y ∨ z) = (x ∧ y) ∨ (x ∧ z).</formula><p>• There exists a smallest element 0, and a greatest element 1, which satisfiy e.g.</p><formula xml:id="formula_113">0 ∨ x = x, 1 ∨ x = 1.</formula><p>• There exists a complement</p><formula xml:id="formula_114">x ∨ ¬x = 1, x ∧ ¬x = 0.</formula><p>Let us check that a Boolean algebra is a CCC.</p><p>• It has a terminal object 1.</p><p>• It has infimums (i.e. products) for all pairs of elements.</p><p>• We define the exponential as Boolean implication, i.e.</p><formula xml:id="formula_115">[a → b] = ¬a ∨ b. Since eval a b : [a → b] × a → b</formula><p>and arrows between objects of posets are unique, we simply have to show that [a → b] ∧ a ≤ b to obtain evaluation arrows:</p><formula xml:id="formula_116">[a → b] ∧ a = (¬a ∨ b) ∧ a = (¬a ∧ a) ∨ (b ∧ a) = 0 ∨ (b ∧ a) = b ∧ a ≤ b</formula><p>Where we used a distributive property, and in the final step the definition of an infimum.</p><p>• Next we need to be able to curry, i.e. show that λf exists. Note that indeed we only have to show that such an arrow exists, by definition every diagram in a poset category commutes, since arrows between objects are unique. Say we have an arrow from a × b → c, i.e. we have a ∧ b ≤ c. Then:</p><formula xml:id="formula_117">a = a ∧ 1 = a ∧ (b ∨ ¬b) = (a ∧ b) ∨ (a ∧ ¬b) ≤ c ∨ (a ∧ ¬b) ≤ c ∨ ¬b ≡ ¬b ∨ c ≡ [b → c]</formula><p>So there is indeed an arrow from a → [b → c], as required.</p><p>Example 5.5 (Small categories as a CCC). Before, we briefly discussed Cat, the category of small categories. Let C, D ∈ Cat, then we can define:</p><formula xml:id="formula_118">[C → D] ≡ Fun(C, D).</formula><p>So the exponentials correspond to the functor categories between the categories in question.</p><p>Let F : C × D → E be a functor, then we want to construct a functor λF : C → <ref type="bibr">[D → E]</ref>. This functor should sends each object c to a functor λF (c) between D and E, and arrows of C to natural transformations between D and E. We define this, using F , as:</p><p>• The functor for c ∈ C:</p><formula xml:id="formula_119">-For objects d ∈ D we have λF (c)(d) = F (c, d). -For arrows g : d → d we have λF (c)(g) = F (id c , g).</formula><p>• The natural transformations for f : c → c in C should be between the functors F (c), F (c ):</p><formula xml:id="formula_120">-For d ∈ D, the component of λF f ≡ µ at d is given by: µ :F (c) ⇒ F (c ) µ d :F (c)(d) → F (c )(d) :F (c, d) → F (c , d) µ d ≡F (f, id d )</formula><p>Let us check that this indeed defines a natural transformation. Let</p><formula xml:id="formula_121">g : d → d in D: F (c, d) F (c , d) F (c, d ) F (c , d ) F (c)(g) µ d F (c )(g) µ d</formula><p>To show that this commutes, we compute:</p><formula xml:id="formula_122">= F (c )(g) • µ d = F (id c , g) • F (f, id d ) = F (id c • f, g • id d ) = F (f • id c , id d • g) = F (f, id d ) • F (id c , g) = µ d • F (c)(g) =</formula><p>Where we used the definition of composition in a product category, and the fact that F is a functor so it plays nice with composition.</p><p>So we can indeed 'curry' in the category of small categories, the other properties (e.g. that it has a terminal object, the category with one object and its identity arrow) are easy to check.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">λ-calculus and categories</head><p>One of the interesting features of a CCC is that it can model a λ-calculus, which is one of the universal models of computations, and corresponds to underlying computational model for functional programming (whereas imperative languages are based on Turing machines).</p><p>In this section we will give a brief and incomplete introduction to (typed) λ-calculus. Our reason to discuss them is to better understand functional languages, and to give further motivation to the definition of CCCs.</p><p>Expressions, or λ-terms, form the key component of λ-calculus. In these expressions there can be variables which are identifiers that can be seens as placeholders, and applications. An expression is defined recursively as one of the following:</p><p>• a variable x.</p><p>• if t is an expression and x a variable, λx.t is an expression (called an abstrac- tion).</p><p>• if t and s are expressions, then so is ts (called an application).</p><p>The only 'keywords' that are used in the λ-calculus language are the λ and the dot. Multiple applications can be dismbiguated using parentheses, where the convention is that they associate from the left if these are omitted, i.e.</p><formula xml:id="formula_123">t 1 t 2 t 3 . . . t n = (. . . ((t 1 t 2 )t 3 ) . . . t n ).</formula><p>Abstractions can model functions, for example the identity function could be written as:</p><p>λx.x</p><p>Note that the choice for the name x is completely arbitrary, equivalently we could have written λy.y ≡ λz.z and so on. This is called α-conversion.</p><p>Note that we do not have to give this function any name, but is simply defined to be the given expression. This is why anonymous functions in programming are often called λ-functions. On the left of the dot we have the arguments preceded by a λ. On the right of the dot we have the body expression.</p><p>Functions like this can be applied to expressions, by substituting the expressions as the 'value' for the argument, i.e. say we have a function evaluated at some point:</p><formula xml:id="formula_124">f (x) = ax, f (y)</formula><p>then the corresponding expression would be:</p><formula xml:id="formula_125">(λx.ax)y ≡ ay</formula><p>This substitution process is called β-reduction, and can be seen as a computational step.</p><p>A variable can be free or bound, for example in our example</p><p>λx.ax, a is free, while x is bound -i.e. associated to an argument. We can make this formal: Definition 5.6 (Free and bound variables). A variable x is free only in the following cases:</p><p>• x is free in x.</p><p>• x is free in λy.t if y = x are not the same identifier, and x is free in t.</p><p>• x is free in st if it is free in either s or t.</p><p>A variable x is bound in the following cases:</p><p>• x is bound in λy.t if y = x is the same identifier, or if x is bound in t.</p><p>• x is bound in st if it is bound in either s or t.</p><p>Note that a variable can be both bound and free in the same expression. For example, y is both bound and free in: (λy.y)(λx.xy).</p><p>Also, note that this implies that the same identifiers may be used indepently in multiple expressions, but should not be mixed up. We should rename identifiers wherever necessary when applying functions.</p><p>Say f does not contain x as a free variable, then we can equivalently write:</p><formula xml:id="formula_126">λx.f x ≡ f, this is called η-conversion.</formula><p>Example 5.7 (Natural numbers). Since the λ-calculus forms a very minimal pro- gramming language, we may expect it to be able to perform basic mathematical tasks. Indeed it can, and as an example we will see how we can model the natural numbers as expressions in λ-calculus.</p><p>We define:</p><formula xml:id="formula_127">0 ≡ λs.(λz.z) ≡ λsz.z,</formula><p>where we also introduced syntax for functions of multiple parameters. Note that by convention these associate from the right, contrary to expressions.</p><p>The natural numbers are defined recursively by applying s to the body of the function corresponding previous number:</p><formula xml:id="formula_128">1 = λsz.sz 2 = λsz.s(sz) 3 = λsz.s(s(sz)) . . .</formula><p>This leads naturally to the succesor function, which correspond to the following expression:</p><formula xml:id="formula_129">S = λwyx.y(wyx).</formula><p>Writing</p><formula xml:id="formula_130">s k z = s(s(s(s(s . . . (sz)))))</formula><p>, with k occurences of s, we can see that:</p><formula xml:id="formula_131">Sk = (λwyx.y(wyx))(λsz.s k z) = (λyx.y((λsz.s k z)yx)) = (λyx.y(y k x)) = (λyx.y k+1 x) ≡ (λsz.s k+1 z) ≡ k + 1</formula><p>In similar ways, one can define addition and multiplication, logical operations, equality, and ultimately even simulate a Turing machine using λ-calculus.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Typed λ-calculus</head><p>In the context of typed functional languages, we are interested in typed λ-calculus. This is an extension of λ-calculus, where each expression has a type. We will sketch this extension and the associated category here, but note that we will freely glance over some technicalities and will not prove anything in too much detail. The goal of this part is to give an idea of how CCCs can be applied more broadly to functional program than just formalizing the notion of function types and currying.</p><p>To define what a type is, we introduce the set of symbols as:</p><formula xml:id="formula_132">S = {S 1 , S 2 , S 3 , . . .}.</formula><p>A type is defined recursively as either:</p><formula xml:id="formula_133">• A symbol S i • If T 1 , T 2 are types, then so is T 1 → T 2 .</formula><p>If t is an expression then we write t : T to indicate that its type is T . Types corresponding to expressions have to obey a number of rules, e.g.:</p><p>• c : T denotes a constant of type T .</p><p>• For each type, there is a countable number of variables x 1 : T , x 2 : T , . . .</p><p>• If t : T 1 → T 2 and s : T 1 then ts : T 2 • For a variable x : T 1 , given an expression t : T 2 , we obtain a function λx.t :</p><formula xml:id="formula_134">T 1 → T 2 .</formula><p>• There is a singleton type 1 with an expression * : 1. Any other expression of this type is equal (see below) to * as seen from Γ = ∅.</p><p>Equations, or equality judgements in this calculus have the form:</p><formula xml:id="formula_135">Γ|t = s : T.</formula><p>Here, Γ is some set of variables that at least contains all the free variables in both t and s. Such an equation means that according to Γ (i.e. with respect to its variables), the expressions t and s of type T are equal. These equations are subjects to some rules, e.g. for fixed Γ they define an equivalence relation of expressions of type T , but we will not list these here. For an overview, see the suggested literature at the end of this chapter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Typed λ-calculus as a CCC</head><p>We can go back and forth between CCCs and λ-calculus. Let us describe how we can obtain a CCC from a typed λ-calculus.</p><p>Definition 5.8. Given a typed λ-calculus L, we associate it to a category C(L) where:</p><p>• The objects are types T .</p><p>• The arrows T → T are pairs of -an equivalence class of expressions of types T . The equivalence of two expressions t, s where t may contain the variable x, and s may contain the variable y, is defined as follows:</p><p>* both s, t are of the same type T * x has the same type as y and is substitutable for it in s (this means that occurence of x becomes bound after substituting it for y in s)</p><p>* {x}|(λy.s)x = t : T. There are multiple reasons for needing this relation, e.g. we want all the expressions of a type T that correspond to single variables to correspond to the same identity arrow of the type T . Also, together with the prop- erties of the singleton type 1, this ensures that we get a terminal object corresponding to the type 1.</p><p>-a free variable x of type T (that does not necessarily have to occur in the expression(s))</p><p>You can prove C(L) is indeed cartesian closed, and also that any CCC defines a λ-calculus, but we will not do this here primarily because the definition given here is incomplete and would be overly long otherwise.</p><p>There are a number of advantages of viewing a λ-calculus from the viewpoint of a CCC. For example, often variables (identifiers) clash between expressions, and this requires carefully renaming variables where necessary. When considering the arrows of the associated CCC, all placeholders have been identified by means of the equivalence relation, and this is no longer an issue. Also, the fact that we can compose arrows means that results from category theory can be used for further reduction of expressions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">References</head><p>• Adjunctions "Adjoint functors arise everywhere"</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Saunders Mac Lane</head><p>There are multiple ways to introduce adjunctions, both in terms of the intuition behind them, as well as the actual definition. The setup is that there are two functors F, G:</p><formula xml:id="formula_136">C D F G</formula><p>that we want to relate. In particular, we want to generalize the inverse of a functor. We say that the functor F is an isomorphism with inverse G if:</p><formula xml:id="formula_137">Id C = GF, F G = Id D</formula><p>where Id C is the identity functor on C, and GF denotes G • F . A weaker notion is isomorphism up to natural isomorphism, where we require that there exists some natural isomorphisms</p><formula xml:id="formula_138">Id C ∼ ⇒ GF, F G ∼ ⇒ Id D</formula><p>Even weaker is that we only require that there exists natural transformations:</p><formula xml:id="formula_139">Id C ⇒ GF, F G ⇒ Id D</formula><p>This is what we are going to explore in this part. We call the triple (F, G, η) an adjunction, and η the unit of the adjunction. We say that F is left adjoint to G, and G is right adjoint to F , or simply F G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Universal arrow adjunctions</head><p>In other words, given an adjunction and any arrow f : c → Gd, i.e. from an arbitrary object of C to something in the image of G (so relevant to the functor G), we can equivalently consider an arrow g : F c → d in D relating to the functor F , because we use the natural transformation η and our functors to convert them to the same arrow.</p><p>This means that the relevant structure of C with respect to the functor G, can also be found in D with respect to the functor F .</p><p>Example 6.2. View Z and R as categories, with a → b ⇐⇒ a ≤ b. Let I : Z → R be the inclusion functor that sends z → ι(z). I is left adjoint to the functor ·· : R → Z that sends r → →r. Indeed, consider the following diagram in Z:</p><formula xml:id="formula_140">z ι(z) = z r z≤z z≤≤r G(ι(z)≤r)</formula><p>the existence of a unique g = ι(z) ≤ r for such an f corresponds to the statement:</p><formula xml:id="formula_141">ι(z) ≤ r ⇐⇒ z ≤ ≤r.</formula><p>For the converse, consider the ceiling functor ·· : R → Z and the following diagram in R:</p><formula xml:id="formula_142">r ι( ι(z) r≤ι(r) r≤ι(z) ι(r≤ι(z))</formula><p>Which corresponds to the statement:</p><formula xml:id="formula_143">r ≤ ι(z) ⇐⇒ ⇒r ≤ z,</formula><p>showing that the inclusion functor is right adjoint to the ceil functor. So we have the adjunction chain: ·· · I ··.</p><p>Example 6.3. An important class of adjunctions take the form free forgetful. Let X be a set. The free monoid F (X) is defined as:</p><formula xml:id="formula_144">F (X) = (X * , + + , ()),</formula><p>see Example 2.1 for the definition of X * , + + denotes the concatenation of words as a binary operator, and () denotes the empty word. F defines a free functor:</p><formula xml:id="formula_145">F : Set → Mon,</formula><p>sending a set to the free monoid over that set. There is also a forgetful functor:</p><formula xml:id="formula_146">U : Mon → Set,</formula><p>sending a monoid to its underlying set, that sends monoid homomorphisms to the corresponding function on sets. We define:</p><formula xml:id="formula_147">η : Id Set ⇒ U • F,</formula><p>as having components defining a function that sends an element x ∈ X to a singleton word containing that element:</p><formula xml:id="formula_148">η X (x) = (x).</formula><p>To show that (F, U, η) form an adjunction, we consider some f :</p><formula xml:id="formula_149">X → U (M )</formula><p>where M is a monoid, and we want to show that there is a unique monoid homomorphism g : F (X) → M that makes the following diagram commute:</p><formula xml:id="formula_150">X U (F (X)) U (M ) η X f U (g)</formula><p>We have to define:</p><formula xml:id="formula_151">g(()) = id M g((x)) = f (x) g((x 1 , x 2 , . . . , x n )) = f (x 1 )f (x 2 ) . . . f (x n )</formula><p>to make g into a monoid homomorphism that satisfies also:</p><formula xml:id="formula_152">f (x) = U (g)(η X x) = U (g)((x)).</formula><p>Before moving on, we first show that there are other definitions of adjunctions, which we will show are equivalent to the one we gave above, but are useful for describing other examples of adjunctions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Equivalent formulations</head><p>There is an alternative way of describing adjunctions, as a natural bijection between hom-sets. </p><formula xml:id="formula_153">Hom D (F c, d) Hom C (c, Gd) Hom C (F c, d ) Hom C (c, Gd ) g•_ φ c,d Gg•_ φ c,d</formula><p>while naturality in C means that for all f : c → c the following diagram commutes:</p><formula xml:id="formula_154">Hom D (F c, d) Hom C (c, Gd) Hom C (F c , d) Hom C (c , Gd) _•F f φ c,d _•f φ c ,d</formula><p>We can show that given a universal arrow adjunction, we can obtain a hom-set adjunction.</p><p>Proposition 6.5. Let (F, G, η) be a univeral arrow adjunction. Then the family of functions:</p><formula xml:id="formula_155">φ c,d : Hom D (F c, d) → Hom C (c, Gd), (α : F c → d) → Gα • η c defines a hom-set adjunction (F, G, {φ c,d } c∈C,d∈D ).</formula><p>Proof. First we show that φ c,d is a bijection. Because (F, G, η) is an adjunction, we know that:</p><formula xml:id="formula_156">∀f : c → Gd, ∃! g : F c → d, s.t. f = Gg • η c .</formula><p>Injectivity of φ c,d is guaranteed by the uniqueness of the arrow g, while surjectivity is guaranteed by the existence of such an arrow.</p><p>Next we have to show that it is natural in both C, and D which means respectively that for all f : c → c and g : d → d :</p><formula xml:id="formula_157">Gα • η c • f = G(α • F f ) • η c (6.1) Gg • Gα • η c = G(g • α) • η c (6.2)</formula><p>Equation 6.1 follows from the functoriality of G and the naturality of η: </p><formula xml:id="formula_158">G(α • F f ) • η c = G(α) • G(F f ) • η c = G(α) • η c • f.</formula><formula xml:id="formula_159">η : Id C ⇒ GF, , : F G ⇒ Id D ,</formula><p>such that the following diagrams (the triangle identities) commute:</p><formula xml:id="formula_160">F F GF F F η id F F G GF G G ηG id G GG</formula><p>where we use the notation (now in components)</p><formula xml:id="formula_161">(ηG) d = η Gd and (F η) c = F (η c ), then (F, G, η, ,)</formula><p>is an adjunction. We call η the unit and the counit of the adjunction.</p><p>Note that this means that the unit is the translated inverse of the counit and vice versa.</p><p>Proposition 6.7. We can construct a unit-counit adjunction (F, G, η, ,) from a hom- set adjunction.</p><p>Proof. We define η and as having components:</p><formula xml:id="formula_162">η c : c → GF c = φ c,F c (id F c ) (6.3) d : F Gd → d = φ −1 Gd,d (id Gd ) (6.4)</formula><p>Let us prove that η is a natural transformation, the proof of the naturality of is dual to this. We want to show that the following diagram commutes for all f : c → c :</p><formula xml:id="formula_163">c GF c c GF c f ηc GF f η c i.e. that: = GF f • η c = η c • f =</formula><p>Plugging in our definition for η c , and using the naturality of φ c,d we see:</p><formula xml:id="formula_164">GF f • φ c,F c (id F c ) = φ c,F c (F f • id F c ) = φ c,F c (id F c • F f ) = φ c ,F c (id F c ) • f = η c • f</formula><p>To show the first triangle identity, i.e. that for all c ∈ C:</p><formula xml:id="formula_165">F c • F (η c ) = id F c ,</formula><p>we use naturality of φ −1 GF c,F c :</p><formula xml:id="formula_166">φ −1 GF c,F c (id GF c ) • F (φ c,F c (id F c )) = φ −1 c,F c (id GF c • φ c,F c (id F c )) = φ −1 c,F c (φ c,F c (id F c )) = id F c</formula><p>For the second triangle identity, i.e. for all d ∈ D:</p><formula xml:id="formula_167">G( d ) • η Gd = id Gd ,</formula><p>we use the naturality of φ Gd,F Gd :</p><formula xml:id="formula_168">G(φ −1 Gd,d (id G d)) • φ Gd,F Gd (id F Gd ) = φ Gd,d (φ −1 Gb,b (id Gb ) • id F Gb ) = φ Gd,d (φ −1 Gb,b (id Gb )) = id Gb</formula><p>To complete the cycle of equalities, we show that we can retrieve our original universal arrow adjunction from the unit-counit adjunction.</p><p>Proposition 6.8. Let (F, G, η, ,) be a unit-counit adjunction. Then (F, G, η) forms a universal arrow adjunction.</p><p>Proof. Let f : c → Gd. We need to show that there is a unique solution to the equation</p><formula xml:id="formula_169">G(?) • η c = f .</formula><p>From the second triangle identity, naturality of η, and functorality of G, we have:</p><formula xml:id="formula_170">G( d ) • η Gd = id Gd G( d ) • η Gd • f = f G( d ) • GF f • η c = f G( d • F f ) • η c = f So that the required g ≡ d • F f : F c → d exists.</formula><p>To show that it is unique, let:</p><formula xml:id="formula_171">f = G(g) • η c F f = F G(g) • F η c d • F f = d • F G(g) • F η c d • F f = g • F d • F η c d • F f = g • id F c d • F f = g</formula><p>So g must be of this form, as required.</p><p>Summarizing what we saw so far, adjunctions can be defined either as:</p><p>1. Universal arrow adjunction: As a triple (F, G, η) together with a universal mapping property. 2. Hom-set adjunction: As a natural bijection between hom-sets 3. Unit-counit adjunction: As <ref type="figure">(F, G, η, ,)</ref> satisfying the triangle identities.</p><p>And we showed 1 =⇒ 2 =⇒ 3 =⇒ 1, meaning that all these definitions are equivalent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Uniqueness of adjoints</head><p>You can show that adjoints are unique up to natural isomorphism. Say respectively. Then we have for all c ∈ C:</p><formula xml:id="formula_172">Hom D (F c, −) Hom C (c, G−) Hom D (F c, −),</formula><p>through natural isomorphisms in Set defined by φ c,− and φ c,− respectively, by composing them we obtain:</p><formula xml:id="formula_173">Hom D (F c, −) Hom D (F c, −),</formula><p>but the Yoneda embedding then says that F c and F c are isomorphic (see Corollary 4.6). To show that these isomorphisms F c → F c define the components of a natural isomorphism F ⇒ F we have to show that the following diagram commutes:</p><formula xml:id="formula_174">F c F c F c F c F f F f</formula><p>Because the Hom-functor Hom C (−, d) is faithful, the above diagram commutes if 1 :</p><formula xml:id="formula_175">Hom(d, F c) Hom(d, F c) Hom(d, F c ) Hom(d, F c ) h d (F f ) h d (F f )</formula><p>which commutes by the naturality of φ c,d (in D).</p><p>We conclude that adjoints are unique up to natural isomorphism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Examples</head><p>Example 6.9. The exponential object of a CCC is described by an adjunction.</p><p>Consider the functor:</p><formula xml:id="formula_176">− × c : C → C, a → a × c, f : a → b → f × id c .</formula><p>Here, f × id c is the unique arrow from a × c → b × c that makes the following diagram commute:</p><formula xml:id="formula_177">a a × c c b × c b c f p 1 p 2 f ×idc idc p 1 p 2</formula><p>If − × c has a right adjoint, which we will suggestively denote:</p><formula xml:id="formula_178">(− × c) (c → −),</formula><p>then for this adjunction, the universal property in Exercise 6.1 states:</p><p>For any g : a × c → b there exists a unique arrow f ≡ λg : a → (c → b) such that the following diagram commutes:</p><formula xml:id="formula_179">b (c → b) × c a × c b g λg×idc</formula><p>so that the universal property for the counit is identical to the universal property of the evaluation function, compare also with Definition 5.2 of a CCC. Since adjoints are essentially unique, the exponential is determined by the adjunction.</p><p>You can show that adjunctions preserve (among other constructions involving universal properties) initial objects, terminal objects and products, which can be used to prove many useful and familiar equalities in a CCC. For example, we have</p><formula xml:id="formula_180">R a (b × c) R a (b) × R a (c) which in the notation a → b ≡ b a says: (b × c) a b a × c a .</formula><p>Conversely, the product functor preserves coproducts, in that</p><formula xml:id="formula_181">(− × c)(a + b) (− × c)a + (− × c)b, or: (a + b) × c (a × c) + (b × c),</formula><p>which shows that CCC's are distributative.</p><p>Other examples:</p><p>• Free/forgetful functor pairs.</p><p>• Groups G and their abelianizations G ab ≡ G/ <ref type="bibr">[G, G]</ref> form an adjunction.</p><p>• As an interesting application that we will see shortly, adjunctions also give rise to monads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Exercises</head><p>Exercise 6.1. Argue using duality that the counit satisfies the following universal mapping property:</p><p>For any g : F c → d there is a unique arrow f : c → Gd such that the following diagram commutes:</p><formula xml:id="formula_182">d F Gd F c d g F f</formula><p>Exercise 6.2. Let ∆ : C → C × C be the diagonal functor defined as:</p><formula xml:id="formula_183">∆a = (a, a) ∆(f : a → b) = (f, f ) : (a, a) → (b, b)</formula><p>Show that if the category C has binary products if and only if ∆ has a right adjoint Π. Here, the functor Π :</p><formula xml:id="formula_184">C × C → C should send (a, b) → a × b.</formula><p>Hint: write the components of the counit and the arrows that arise in the universal arrow property of the counit (see Exercise 6.1), in terms components of C × C, i.e.</p><formula xml:id="formula_185">d = (p 1 , p 2 ), f = (q 1 , q 2 ).</formula><p>Use that a diagram in C×C commutes if and only if the diagrams for each component commute, and show that you obtain the definition for the binary product.</p><p>Exercise 6.3. Although we proved almost everything equationally in this part, some parts can be proved more efficiently using the Yoneda lemma, for example we consider the natural bijection in the definition of a hom-set adjunction as a natural transformation between the hom-functors:</p><formula xml:id="formula_186">Hom(F −, −) ⇒ Hom(−, G−)</formula><p>from C op × D → Set. Think about this. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">References</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Henri Poincaré</head><p>Monads are used all throughout functional programming. In this part, we will try to understand them by first studying their mathematical definition and properties.</p><p>Afterwards, we describe their use in functional programing by giving a number of motivating examples.</p><p>Any endofunctor T : C → C can be composed with itself, to obtain e.g. T 2 and T 3 (which are both again endofunctors from C to C. A monad concerns an endofunctor, together with natural transformation between this functor and its composites that give it a "monoid-like structure".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Monads over a category</head><p>Say α is a natural transformation T ⇒ T , where T, T are endofunctors of C, then note that α x is a morphism from T x → T x in the category C. Since this is a morphism, we can use T or T to lift it, i.e. we obtain arrows at components (T α) a ≡ T (α a ) and (αT ) a ≡ α T a .</p><p>In particular, note that this defines natural transformations between the appropriate composite functors since the image of any commutative diagram under a functor is again commutative.</p><p>We are now ready to dive into the definition of a monad: </p><formula xml:id="formula_187">η : Id ⇒ T µ : T 2 ⇒ T</formula><p>so that the following diagrams commute:</p><formula xml:id="formula_188">T 3 T 2 T 2 T T µ µT µ µ T T 2 T T ηT id µ T η id</formula><p>The first of these is called the associativity square while the two triangles in second diagram are called the unit triangles.</p><p>We call η the unit, and µ the multiplication. Let us look at a familiar example:</p><p>Example 7.2 (Power-set monad). Let P be the power-set functor that we defined before. We define η as the natural transformation:</p><formula xml:id="formula_189">η : Id ⇒ P,</formula><p>with components that send elements to the singleton set corresponding to that element:</p><formula xml:id="formula_190">η A : A → P(A), a → {a}.</formula><p>We define µ as the natural transformation:</p><formula xml:id="formula_191">µ : P 2 → P,</formula><p>with components that send each set of sets, to the union of those sets.</p><formula xml:id="formula_192">µ A : P(P(A)) → P(A), {B 1 , B 2 , . . .} } → B i ,</formula><p>where B i ⊆ A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">Adjunctions give rise to monads</head><p>Let (F, G, η, ,) be a unit-counit adjunction. We have a functor:</p><formula xml:id="formula_193">T ≡ GF : C → C.</formula><p>We can define a natural transformation:</p><formula xml:id="formula_194">µ : T 2 ⇒ T, µ c ≡ G( F c ).</formula><p>Let us show that (T, η, µ) indeed forms a monad, first the associtivity square:</p><formula xml:id="formula_195">GF GF GF GF GF GF GF GF GF µ µGF µ µ</formula><p>Looking at this diagram in terms of components and substituting in the definition of µ we obtain</p><formula xml:id="formula_196">GF GF GF c GF GF c GF GF c GF c GF G( F c ) G( F GF c ) G( F c ) G( F c )</formula><p>written more suggestively we write: a ≡ F GF c, b ≡ F c and˜Gand˜ and˜G ≡ GF G,</p><formula xml:id="formula_197">˜ Ga Gã Gã Gb Gb˜G Gb˜ Gb˜G( b ) G(a) G( b ) G( b )</formula><p>such that the diagram reveals itself to be a naturality square under the function f ≡ b : a → b for the natural transformation GG.</p><p>For e.g. the left unit triangle we observe:</p><formula xml:id="formula_198">GF c GF GF c GF c id GF c η GF c G( F c )</formula><p>Which is just the second triangle identity of the adjunction at the object F c.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.2">Kleisli categories</head><p>Every monad defines a new category, called the Kleisli category.</p><p>Definition 7.3. Let C be a category, and let (T, η, µ) be a monad over this category.</p><p>Then the Kleisli category C T is the category where:</p><p>• The objects of C T a T correspond directly to the objects a of C.</p><p>• The arrows of C T are the arrows of the form f : a → T b in C, and will be denoted f T . In other words,</p><formula xml:id="formula_199">Hom C T (a T , b T ) Hom C (a, T b).</formula><p>• Composition between two arrows f T :</p><formula xml:id="formula_200">a T → b T and g T : b T → c T in C T is</formula><p>given by:</p><formula xml:id="formula_201">g T • T f T ≡ (µ c • T g • f ) T .</formula><p>• The identity arrows id a T are equal to (η a ) T .</p><p>Let us show that this indeed forms a category. In particular we have to show that the composition operator is associative and unital. For the former, we look at the following situation</p><formula xml:id="formula_202">a T b T c T d T f T g T h T</formula><p>the left associative and right associative expressions are:</p><formula xml:id="formula_203">(h T • T g T ) • T f T = (µ d • T h • g) T • T f T = (µ d • T (µ d • T h • g) • f ) T , h T • T (g T • T f T ) = h T • T (µ c • T g • f ) T = (µ d • T h • µ c • T g • f ) T ,</formula><p>so it is enough to show that:</p><formula xml:id="formula_204">µ d • T µ d • T 2 h = µ d • T h • µ c ,</formula><p>which holds because of the associativity square and the naturality of µ:</p><formula xml:id="formula_205">µ d • T µ d • T 2 h = µ d • µ T d • T 2 h = µ d • T h • µ c</formula><p>To show that it is e.g. left-unital we compute:</p><formula xml:id="formula_206">id b T • T f T = (µ b • T (η b ) • f ) T = f T</formula><p>where we use the right unit triangle of the monad:</p><formula xml:id="formula_207">µ b • T η b = id b</formula><p>Understanding Kleisli composition can be a convenient stepping stone to under- standing how to work with Monads in Haskell. The composition operator • T is usually denoted &gt;=&gt; (the fish operator) in Haskell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.3">Every monad is induced by an adjunction</head><p>Let C be a category, (T, η, µ) a monad over C, and C T the associated Kleisli category.</p><p>Here, we will show that there are functors F : C → C T and G : C T → C so that F G and T is equal to the monad induced by that adjunction.</p><p>We define:</p><formula xml:id="formula_208">F T : C → C T , a → a T , (f : a → b) → (η b • f ) T G T : C T → C, a T → T a, (f : a → T b) T → µ b • T f</formula><p>Let us check that e.g. F T is actually a functor. Consider two arrows in C, f : a → b and g : b → c.</p><formula xml:id="formula_209">F T (id a ) = (η a ) T ≡ id a T F T (g • f ) = (η c • g • f ) T F T (g) • T F T (f ) = (η c • g) T • T (η b • f ) T = (µ c • T (η c • g) • η b • f ) T</formula><p>So we have to show that:</p><formula xml:id="formula_210">µ c • T (η c ) • T g • η b ? = η c • g,</formula><p>which is immediate from the right unit triangle, and the naturality of η.</p><p>Next we show that F T G T , in that (F T , G T , η) (we take the unit of the adjunction to be equal to the unit of the monad) forms an adjunction in the universal arrow sense. We have to show that for each f : a → T b there is a unique g T : a T → b T ≡ (g : a → T b) T so that the following diagram commutes:</p><formula xml:id="formula_211">a T a T b ηa f µ b •T g</formula><p>Using the left unit triangle, we obtain that it is sufficient and necessary to take simply</p><formula xml:id="formula_212">g T ≡ f T !</formula><p>The counit of the adjunction is given by</p><formula xml:id="formula_213">b T ≡ (id T b ) T : (T a) T → a T . We have T ≡ G T F T ,</formula><p>and we have that</p><formula xml:id="formula_214">G T ( F T a ) = G T ( a T ) = G T ((id T a ) T ) = µ a • T (id T a ) = µ a</formula><p>as required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Monads and functional programming</head><p>Because the brutal purity of Haskell is restrictive, we need non-standard tools to perform operations that we take for granted in imperative languages. In this section, we will explore what this means for some real world programs, and discover what problems and difficulties pop up. In particular, we will see how we can use monads to overcome some of these problems, by showing that functions of the type a -&gt; T b are common, and hence that we are in need of a nice way to compose them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">IO</head><p>Consider the type of some functions in Haskell regarding input and output in Haskell: In Haskell, this is done using IO actions. This monadic style of doing IO is not limited to input/output for terminal, it can also be network related, file related, or mouse/keyboard input for a video game! An IO action is a value with a type of IO a. We can also have an 'empty IO action', if the result is not used. The way to look at these actions is as a recipe of producing an a. While the actual value produced by the action depends on the outside world, the recipe itself is completely pure.</p><p>Let us consider our examples:</p><p>• The print function has the signature from a String to an IO action: • The function main itself is an IO action! So the type is main :: IO ().</p><p>• The getLine function is an IO action getLine :: IO String.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Case study: Handling input</head><p>Let us consider a very simple example using getLine and print.  Next, we have that f expects an Int, not an IO Int, so we lift it again --attempt 3 main = print $ f &lt;$&gt; (read &lt;$&gt; getLine :: IO Int)</p><p>The print 1 statement we used here has signature a -&gt; IO (). Bringing this into the IO context using an fmap gives us:</p><formula xml:id="formula_215">fmap print :: IO a -&gt; IO (IO ())</formula><p>Since main should corespond to IO (), we need either a way to remove a 'nested IO tag', or we need a function for functors that only lifts the first argument. In other words, let F be a functor, then we require either: Note, that we can define:</p><formula xml:id="formula_216">join :: F (F a) -&gt; F a (=&lt;&lt;) :: (a -&gt; F b) -&gt; (F a -&gt; F b) --the</formula><formula xml:id="formula_217">join :: F (F a) -&gt; F a join x = x &gt;&gt;= id</formula><p>so that implementing &gt;&gt;= is enough. Conversely, we can also retrieve bind from join and fmap:</p><p>x &gt;&gt;= f = join (f &lt;$&gt; x)</p><p>Note also that we can pack an object inside an IO 'container':</p><p>return :: a -&gt; IO a</p><p>Let us return to IO, and see what this notation gives us:</p><formula xml:id="formula_218">main = getLine &gt;&gt;= putStrLn</formula><p>This code results in an empty action IO (), so the 'bind' function can be used to chain IO operations together! For our little toy program we can fmap print into the IO context, and join the result afterwards to obtain:</p><formula xml:id="formula_219">main = join $ print &lt;$&gt; f &lt;$&gt; (read &lt;$&gt; getLine :: IO Int)</formula><p>Using a more idiomatic style of writing this programming we get:</p><formula xml:id="formula_220">main = read &lt;$&gt; getLine &gt;&gt;= (\x -&gt; print (f x))</formula><p>which in do-notation becomes:</p><formula xml:id="formula_221">main = do x &lt;-read &lt;$&gt; getLine print (f x)</formula><p>To summarize, &gt;&gt;=, join and return allow us to compose functions that may or may not require IO operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">Other examples</head><p>Now that we have seen how to compose functions of the form a -&gt; T b, let us look at some other examples of contexts where this structure can be found.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data structures</head><p>• a -&gt; Maybe b: a function that may fail.</p><p>• a -&gt; <ref type="bibr">[b]</ref>: a function that may produce zero or more results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Logging</head><p>All of IO, Maybe and [] may be seen as 'functional containers', let consider a different kind of example.</p><p>data Logger m a = Logger (a, m)</p><p>The data type Logger consists of a composable log (in the form of a monoid, e.g. (String, (++))) m, and an embedded value a.</p><p>• a -&gt; Logger String b: a function that may log a string. In this view, a value of type State s a is a function that takes some state, and produces an a in addition to a (possibly modified) state. For example, s could be some environment (say a Map) containing information that can be used to produce an a, and the state function can manipulate this Map when producing the a.</p><p>• a -&gt; State s b: a function that uses and/or manipulates a state.</p><p>In these examples, the contexts are The bind &gt;&gt;= implementation for these monads pass around this context, and can change the control depending on the result after a step. For example, it can short- circuit a computation inside the Maybe monad in case some function fails.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.3">The Monad type class</head><p>The triplets <ref type="bibr">(F, return, join)</ref> that we have seen in this section, correspond to monads (T, η, µ) over the category of types. The type class in Haskell is defined as 2 :</p><p>class We have seen that &gt;&gt;= can be defined in terms of join, which has the familiar type:</p><formula xml:id="formula_222">join :: m (m a) -&gt; m a</formula><p>Indeed, return corresponds to a natural transformation Identity -&gt; m, while join corresponds to a natural transformation between m m -&gt; m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Exercises</head><p>Exercise 7.1. Show that the image of any commutative diagram under a functor F is again commutative.</p><p>Exercise 7.2. Show that G T is a functor. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">References</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Recursion and F-algebras</head><p>In this part we introduce F -algebras, which are not only an important theoretical tool for studying recursion (for functions and data types), but as we will see can also be applied in functional programming to obtain modular descriptions of recursive functions, allowing us to perform multiple transformations over data structures in a single pass, as well as decoupling the recursion scheme from the actual transformation or computation performed at every level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Algebras for endofunctors</head><p>Definition 8.1. Let F : C → C be an endofunctor. An F -algebra is a pair (a, α) where a ∈ C and α : F a → a is an arrow in C. The object a is called the carrier of the algebra.</p><p>A homomorphism between F -algebras (a, α) and (b, β) is an arrow h : a → b such that the following diagram commutes:</p><formula xml:id="formula_223">F a a F b b α F h h β</formula><p>For every endofunctor F , the collection of F -algebras together with homomor- phisms of these F -algebras form a category which we will denote Alg F .</p><p>Recall that a fixed point of a function f is an x in the domain of f , such that f (x) = x. Considering this, a sensible definition for a fixed point of an endofunctor would be an object a such that F (a) = a, but we will be a bit more lenient, and only require that F (a) a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8.2.</head><p>A fixed point of F is an algebra (a, α) for which α is an isomor- phism.</p><p>A special fixed point is the least fixed point. We take inspiration from partially ordered sets, where the least point is an initial object, and define it as follows.</p><p>Definition 8.3. A least fixed point of F is an initial algebra (a, α), i.e. an algebra that is an initial object in the category Alg F .</p><p>An immediate issue that we have to resolve is to show that any least fixed point is indeed a fixed point.</p><formula xml:id="formula_224">Lemma 8.4 (Lambek). Let F : C → C be an endofunctor. If (t, τ ) is initial in Alg F , then τ is an isomorphism.</formula><p>Proof. Let (t, τ ) be an initial object in Alg F , and consider the algebra (F t, F τ ). Since (t, τ ) is initial there is a unique homomorphism h : t → F t such that the following diagram commutes:</p><formula xml:id="formula_225">F t t F 2 t F t F t t τ F h h F τ F τ τ τ</formula><p>Here, the top square commutes because h is a homomorphism, and the bottom square commutes trivially. First, we note that by commutativity of this diagram, τ • h is a homomorhism between (t, τ ) → (t, τ ), and since (t, τ ) is initial it is the unique homomorphism, i.e. the identity, and hence:</p><formula xml:id="formula_226">τ • h = id t ,</formula><p>i.e. h is a right inverse to τ . To show that it is also a left inverse (and hence that τ is an isomorphism) we compute using the commutativity of the top square:</p><formula xml:id="formula_227">h • τ = F τ • F h = F (τ • h) = F (id t ) = id F t .</formula><p>which shows that τ is an isomorphism, and hence that (t, τ ) is a fixed point.</p><p>Let (a, α) be an F -algebra. In the functional programming literature, the unique homomorphism from the initial algebra (t, τ ) to (a, α) is called a catamorphism and is denoted (|α|).</p><p>The following result is a useful tool when working with catamorphisms.</p><p>Proposition 8.5 (Fusion law). Let F : C → C be such that it has an initial algebra. Let (a, α) and (b, β) be F -algebras and let h be an algebra homomorphism between them. Then:</p><formula xml:id="formula_228">h • (|α|) = (|β|).</formula><p>Proof. This is immediate from the following commutative diagram:</p><formula xml:id="formula_229">F t t F a a F b b τ F (|α|) (|α|) α F h h β</formula><p>Note that h • (|α|) is a homomorphism, and since (t, τ ) is initial it should correspond to the unique homomorphism (|β|).</p><p>The following examples are from 'Bart Jacobs, Jan Rutten; A tutorial on (co)algebras and (co)induction'. Example 8.6 (Peano numbers). Consider the endofunctor on Set given by:</p><formula xml:id="formula_230">F (X) = 1 + X.</formula><p>We can construct an algebra of this functor with carrier N ≥0 , the set of natural numbers, as follows:</p><formula xml:id="formula_231">ν : F (N) → N ≡ 1 + N → N, ν ≡ 0 s</formula><p>here s(n) ≡ n + 1 denotes a successor function, and 0 denotes the constant function to 0 ∈ N.</p><p>If f : a → c, g : b → c, then the notation f g : a + b → c denotes the unique arrow that factors the arrows f, g.</p><p>We will show that (N, ν) is in fact the initial algebra for F . To this end, let (A, α) be any other F -algebra, where α = a h for some a ∈ A, and h : A → A. We define the candidate homomorphism (|α|) between (N, ν) and (A, α) to be:</p><formula xml:id="formula_232">(|α|)(n) ≡ h n (a),</formula><p>i.e. (|α|)(0) = a, (|α|)(1) = h(a) and so on.</p><p>We have to show that 1) it is indeed a homomorphism of F -algebras, and 2) that it is the unique such homomorphism.</p><p>For the former, we show that the following diagram commutes:</p><formula xml:id="formula_233">1 + N N 1 + A A id * (|α|) ν (|α|) α</formula><p>We do this directly, by chasing an element from the top left. We consider an x ∈ 1+N. There are two cases, either x is in 1, for which we will write x = * , or in N, for which we will write x = n. If x = * then:</p><formula xml:id="formula_234">= (|α|)(ν( * )) = (|α|)(0) = a, = α(id * ( * )) = α( * ) = a,</formula><p>as required. If x = n then:</p><formula xml:id="formula_235">= (|α|)(ν(n)) = (|α|)(n + 1) = h n+1 (a), = α((|α|)(n)) = α(h n (a)) = h n+1 (a),</formula><p>such that (|α|) is indeed a homomorphism. Letting g be an arbitrary homomorphism, then following the previous argument in reverse shows that g ≡ (|α|) such that it is unique, and (N, ν) is indeed initial.</p><p>Example 8.7 (Lists). Next, we consider the endofunctor on Set given by:</p><formula xml:id="formula_236">F (X) = 1 + (A × X).</formula><p>We consider the list algebra (A * , () ()). Here, A * is the Kleene closure introduced in Example 2.1, () denotes the (constant function to) the empty list, and () : A × A * → A, the prepend function, (which we will write using infix notation) is defined as: a a (a 1 , a 2 , a 3 , . . .) = (a, a 1 , a 2 , a 3 , . . .).</p><p>Let (B, β), with β = b h where b ∈ B and h : A × B → B, be any other F -algebra, and define the candidate homomorphism:</p><formula xml:id="formula_237">(|β|) : A * → B,</formula><p>between the list algebra and this algebra as:</p><formula xml:id="formula_238">(|β|)(˜ x) =    b if˜xif˜ if˜x = () h(x, (|β|)(˜ y)) if˜xif˜ if˜x = x x ˜ y</formula><p>To show that this indeed a homomorphism, we look at the diagram:</p><formula xml:id="formula_239">1 + (A × A * ) A * 1 + (A × B) B id * (id A ×(|β|)) ()() (|β|) bh</formula><p>Like in the previous example, we split in two cases. First, let x = * , then:</p><formula xml:id="formula_240">= (|β|)(()( * )) = (|β|)(()) = b, = b(id * ( * )) = b.</formula><p>Next, we let x = a × ˜ a, and compute:</p><formula xml:id="formula_241">= (|β|)(()(a × ˜ a)) = (|β|)(a a ˜ a) = h(a × (|β|)(˜ a)), = h((id A × (|β|))(a × ˜ a)) = h(a × (|β|)(˜ a)),</formula><p>as required. To show that it is the unique such arrow, we again follow the previous argument in reverse.</p><p>Note in both of these examples, the catamorphisms correspond to the usual notions of folds (see the Haskell exercises). It is in this sense, that catamorphisms are a generalization of folds (and thus lead to a specific recursion scheme).</p><p>When does a least fixed point exist? Lambek's theorem implies that e.g. the P power-set endofunctor does not have an initial algebra because P(X) is never isomorphic to X (Cantor's theorem).</p><p>Before we can state a sufficient condition for the existence of initial algebras, we first have to introduce the categorical notion of limits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Limits</head><p>We have already come across an example of a limit, namely the categorical (binary) product. Recall that a product a × b has a universal property of the form for any other object c with morphisms to a and b, we can factor the morphisms through a × b. This turns out to be a very general pattern that will define a limit. First, we will give two more examples of limits before stating the formal definition. We will follow roughly the discussion in Chapter 5 of Leister.</p><p>Definition 8.8 (Fork and equalizer). A fork from a at x to y in a category C is defined by the data:</p><formula xml:id="formula_242">a x y f s t such that s • f = t • f .</formula><p>Given a diagram in C of the form:</p><p>x y s t An equalizer of s and t is an object e ∈ C and a map i : e → x such that:</p><formula xml:id="formula_243">e x y i s t</formula><p>is a fork, and for each other fork from some a at x to y, there exists a unique map ¯ f such that the following diagram commutes:</p><formula xml:id="formula_244">a e x ¯ f f i</formula><p>For example, in Set the equalizer E of two functions s, t : X → Y is given by:</p><formula xml:id="formula_245">E = {x ∈ X | s(x) = t(x)}.</formula><p>with i the inclusion E E→ X. It is easy to see that for all forks from some A at X to Y , that we must have A ⊆ E, such that ¯ f is simply the inclusion A A→ E.</p><p>Before we finally give the definition of a limit, we first formalize the notion of a diagram.</p><p>Definition 8.10. Let C be a category. Let A be some (typically small) category. A diagram in C of shape A is a functor A → C.</p><p>The relevant shapes (small categories) of the diagrams for products, equalizers and pullbacks respectively are given by:</p><formula xml:id="formula_246">T = • • E = • • P = • • •</formula><p>Definition 8.11 (Limit). Let C be a category, A a small category, and D : A → C a diagram in C.</p><p>A cone on the diagram D is given by an object n ∈ C, with a family of arrows indexed by the objects x ∈ A:</p><formula xml:id="formula_247">(f x : n → Dx) x∈A ,</formula><p>such that for all maps u : x → y in A, the following diagram commutes: You can think of the vertex of a cone as 'hovering above the diagram D in C', with maps extending to each vertex in Dx, which indeed forms the shape of a cone.</p><p>There are of course also the dual notions of colimits, cocones and so on. In fact, in the following we are mostly interested in colimits.</p><p>Let us sketch why Set has all limits, i.e. that Set is complete. Note that, as always, there is also the dual notion of being cocomplete.</p><p>We let D : A → Set be a diagram.</p><p>• We write L = lim ← − D for the (candidate) limit of D.</p><p>• For each set X we have X Hom Set (1, X), where 1 is the singleton set (for every element of X there is a unique map from 1). Note that L is some set. • Note that in general, for any limit ∈ C of some diagram D, and any a ∈ C, cones with vertex a are in bijection with maps a → . Indeed, any such map leads to a cone by composition with the projections from . Conversely, for each cone a unique such arrow is given by ¯ f , by definition of the limit.</p><p>This means in particular that:</p><formula xml:id="formula_248">L = lim ← − D Hom Set (1, L) {cones on D with vertex 1} {(x a ) a∈A | x a ∈ Da such that ∀u : a → b in D we have Du(x a ) = x b }</formula><p>In other words, the limit corresponds to all possible tuples with elements in Da, indexed by elements of A, that are compatible with the structure of the diagram.</p><p>This can be used to show that Set has all limits. Set is in fact bicomplete (both complete and cocomplete).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.1">ω-chains</head><p>Next, we follow the discussion in Chapter 5 and Chapter 10 of Awodey. Presently, in the context of initial algebras, we are interested in diagrams of shape ω : (N, ≤), i.e. the poset structure of the natural numbers seen as a category, which has the shape:</p><formula xml:id="formula_249">ω = . . . • • • •</formula><p>of course along with the composites of these arrows. Because the diagram is induced by a functor, we can ignore these composite arrows since we can define them to get taken to the composites of the images of the arrows that are pictured. A diagram of shape ω in a category C takes the form:</p><formula xml:id="formula_250">. . . a 3 a 2 a 1 a 0 f 3 f 2 f 1 f 0</formula><p>we will call a diagram like this an ω-chain. If there exists a colimit for all ω-chains, then we say C has ω-colimits. We can denote the the colimit of an ω-chain like the one above as:</p><formula xml:id="formula_251">a ω = lim − → a i .</formula><p>As a final notion, note that if F is an endofunctor, then for each ω-chain (or more generally each diagram D of shape A), we obtain another ω-chain (diagram F D of shape A):</p><formula xml:id="formula_252">. . . F a 3 F a 2 F a 1 F a 0 F f 3 F f 2 F f 1 F f 0</formula><p>We say that a functor F preserves ω-colimits (or is ω-cocontinuous) if:</p><formula xml:id="formula_253">lim − → F a i = F lim − → a i .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Polynomial functors have initial algebras</head><p>Definition 8.12 (Polynomial functor). Let C be a category with finite (co-)products. A polynomial functor from C → C is defined inductively as:</p><p>• The identity functor Id C is a polynomial functor.</p><p>• All constant functors ∆ c : C → C are polynomial functors.</p><p>• If F and F are polynomial functors, then so are</p><formula xml:id="formula_254">F • F , F + F and F × F .</formula><p>For example, the functors F (X) = 1 + X (natural numbers) and F (X) = 1 + A × X (lists) that we treated before are polynomial.</p><p>Lemma 8.13. Polynomial functors on Set are ω-cocontinuous.</p><p>Proof. Constant and identity functors clearly preserve colimits. It is a general result that compositions, products and coproducts of preserving functors are also preserving.</p><p>Now we arive at the main result of this chapter, which I have seen attributed to either Adamek, or to Smyth and Plotkin:</p><p>Proposition 8.14. Let C be a category. If C has an initial object 0 and ω-colimits, and if the functor: F : C → C preserves ω-colimits, then F has an initial algebra.</p><p>Proof. Let f ! be the unique arrow 0 → F 0. Consider the ω-chain:</p><formula xml:id="formula_255">. . . F 3 0 F 2 0 F 0 0 F 3 f ! F 2 f ! F f ! f !</formula><p>Let be the object of the limit of this sequence Since F preserves colimits, we have:</p><formula xml:id="formula_256">F F ≡ F lim − → F i lim − → F (F i 0) F i 0 ≡ .</formula><p>here, the last isomorphism says that the limit of the ω-chain disregarding 0 is the same as the one of the original ω-chain. Intuitively, 0 has a unique arrow to the limit anyway, so removing it does not change anything.</p><p>So we have an isomorphism φ : F F . To show that (, φ) is initial we consider any F -algebra (a, α), and look at the data:</p><formula xml:id="formula_257">F F F a a F 0 0 F g ∼ g α f ! a !</formula><p>Note that any F -algebra (a, α) defines a cocone with vertex a, and family of mor- phisms:</p><formula xml:id="formula_258">(α i : F i 0 → a) i∈ω ,</formula><p>denoting with a ! : 0 → a the unique arrow from 0 to a, we define α i inductively as:</p><formula xml:id="formula_259">α 0 ≡ a ! α n = α • F (α n−1 )</formula><p>We will write for the colimit cocone with vertex :</p><formula xml:id="formula_260">(c i : F i 0 → ) i∈ω .</formula><p>To show that there is a unique algebra homomorphism which we suggestively denote (|α|) from to a, we will first show that if it exists, then it should be the unique mediating arrow ¯ f between the cocones with vertices and a respectively, i.e. we should have for all i ∈ ω:</p><formula xml:id="formula_261">(|α|) • c i = α i .</formula><p>The first case is trivially true, because both arrows have domain 0 which is initial. We proceed using induction, and we use thata F F is the vertex of a cocone (F c n ), and the mediating arrow has to be given by the isomorphism φ:</p><formula xml:id="formula_262">(|α|) • c n+1 = (|α|) • φ • F (c n ) = α • F (|α|) • F c n = α • F ((|α|) • c n )) = α • F (α n )) = α n+1</formula><p>So that if such a homomorphism (|α|) exists, it is unique by the uniqueness of the mediating arrow. To show that it exists, we define it as the mediating arrow, and show that this is a algebra homomorphism. We do this by showing that both:</p><p>(|α|) • φ, and α • F (|α|).</p><p>are mediating between the cones of F F and a, and must therefore correspond to the unique mediating arrow (showing that the mediating arrow is an homomorphism).</p><p>The cases for i = 0 are again trivial. The inductive step for the first arrow:</p><formula xml:id="formula_263">(|α|) • φ • F c n = (|α|) • c n+1 = α n+1</formula><p>In the first step, we use the φ is mediating between the cones at F F and , and at the second step we use that we defined (|α|) to be mediating between and a. For the second arrow:</p><formula xml:id="formula_264">α • F (|α|) • F c n = α • F ((|α|) • c n ) = α • F (α n ) = α n+1</formula><p>as required.</p><p>Corollary 8.15. Every polynomial functor F : Set → Set has an initial algebra.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Least fixed points in Haskell</head><p>In this part we will assume familiarity with the foldr class of functions, see the exercises and the appendix on Haskell.</p><p>In Haskell, the point of using F -algebras is to convert functions with signature:</p><formula xml:id="formula_265">alpha :: f a -&gt; a</formula><p>for a given functor f, to functions that look like:</p><formula xml:id="formula_266">alpha' :: Fix f -&gt; a</formula><p>where Fix f is the fixed point of f. Compared to our category theory notatation we have:</p><formula xml:id="formula_267">alpha ≡ α alpha ≡ (|α|)</formula><p>So the universal property corresponding to a least fixed point in Haskell, expressed in Haskell, is the existence of a function that does this conversion of α to (|α|). Let us call it cata:</p><formula xml:id="formula_268">cata :: (f a -&gt; a) -&gt; Fix f -&gt; a</formula><p>Whenever you see a universal property like this in Haskell, and you want to find out what the type of Fix f should be, there is an easy trick, we simply define the type to have this universal property. Now we have our cata function, but it is of no use if Fix f is not inhabited. We want to be able to convert any value of type f a into a Fix f value. We first introduce the following equivalent description of Fix' f is sometimes written as µF (or Mu f in Haskell).</p><p>So, in summary, catamorphing an algebra can be done recursively using: </p><formula xml:id="formula_269">type</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Using catamorphisms in Haskell</head><p>To give an interpretation of cata, we first show how we usually construct values of And it allows us to perform our optimizations independently, during the same traversal, e.g.: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.6">References</head><p>Books:</p><p>• Limits are in all basic CT books, here we followed Tom Leinster Basic Category Theory</p><p>• Barr &amp; Wells: Chapter 14 deals with F-algebras and fixed points, or final chapter of Awodey • Some theory on fixed points in Haskell can be found in 'Hinze; Adjoint Folds and Unfolds' and 'Bird; Generalized Folds for RDT'. See also Philip Wadler; Recursive types for free.</p><p>• Catamorphisms and its siblings were popularized by 'Meijer et al; Fucntional</p><p>Programming using bananas, envelopes and barbed wire'. Also discussed in 'Bird, de Moor; Algebra of Programming'.</p><p>On the web:</p><p>• We have established some interesting notions such as monads and F -algebras, but we have not yet looked at their dual statements. In this chapter we will partly remedy this shortcoming.</p><p>Over the last couple of chapters, we have grown to appreciate the usefulness of monads. Here, we will explore the dual notion of a comonad.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">Definition</head><p>As with all dual notions, we can simply say that a comonad is a monad on C op . But let us give the definition here explicitely: Definition 9.1. A comonad W = (T, ,, δ) over a category C, consists of an endo- functor T : C → C together with natural transformations:</p><p>:</p><formula xml:id="formula_270">T ⇒ Id δ : T ⇒ T 2</formula><p>so that the following diagrams commute:</p><formula xml:id="formula_271">T 3 T 2 T 2 T T δ δT δ δ T T 2 T T T id δ T T id</formula><p>We call the counit, and δ the comultiplication. These are called extract and duplicate in Haskell.</p><p>We note that by duality every adjunction F G gives rise to a comonad on D.</p><p>Conversely, every comonad arises from an adjunction (by factoring through e.g. the co-Kleisli category). The dual of an F -algebra is an F -coalgebra, and is given by an arrow a → F a. These form a category Coalg F .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2">Comonads in Haskell</head><p>For our purposes, we will define comonads in Haskell using the following typeclass:</p><p>class Functor w =&gt; Comonad w where extract :: w a -&gt; a duplicate :: w a -&gt; w (w a)</p><p>We also have the equivalent of bind, which is usually called extend: The extract function is clear, it simply takes out the head of the stream.</p><p>The duplicate method is more interesting, it creates and infinite number of streams, each focused around (that is to say, 'has at its head') different elements of the original stream. That is to say, the result represents all possible tails of the stream.</p><p>Note that the expressive power gained by working with infinite lists of infinite lists is brought to us by the laziness of Haskell.</p><p>This example immediately suggests a way of looking at (this specific class of) comonads, namely as a container of values with one distinguished value (the one returned by extract), and a duplicate function that can be used to shift the focus (that is to say, change which value is distinguished).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Store</head><p>Store is dual to the State monad 1 , and is defined as:</p><formula xml:id="formula_272">data Store s a = Store (s -&gt; a) s</formula><p>We interpret a Store as follows. The first part, with signature (s -&gt; a) of a store, can be seen as a container with values of type a, which are keyed by elements of type s, so the container is a dictionary. Indeed, for any key x :: s, we can use the first component to obtain a value of type a.</p><p>The second part of type s defines the focus of our store, the distinguished element is the one keyed by this value.</p><p>Store is a functor, by using composition: The semantics of extract are clear and should not be surprising, we simply obtain the distinguished value.</p><p>The implementation of duplicate is harder to digest. Let us first interpret the specialized signature (parentheses added for emphasis): In other words, we are given a dictionary with a distuingished key, keys of type s and values of type a. From duplicate, we obtain a dictionary of dictionaries, with a distuinguished dictionary, keys of type s, and values which are dictionaries. Quite a mouthful!</p><p>Intuitively, this distuinguished dictionary should correspond to our original dictio- nary. The other dictionaries indexed with a key x :: s, should be focused around the element with key x of our original dictionary! We can achieve this by partially evaluating our Store constructor. Observe that:</p><p>Store f :: s -&gt; Store s a takes a key x :: s, and gives us back a store with dictionary f, and distinguished key x. By leveraging this function, we see that the dictionary in the Store re- turned by duplicate, takes a key and returns a Store s a, focused on that key, as required.</p><p>As we will see later, the Store comonad is an important ingredient of the magnifi- cant lens library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3">Comonad laws in Haskell</head><p>We will consider the following form of the laws that a comonad should satisfy in Haskell.</p><formula xml:id="formula_273">extend extract = id --(1) extract . extend f = f --(2) extend f . extend g = extend (f . extend g) --(3)</formula><p>Let us discuss the intuition behind these laws, specifically for the case of comonadic containers. We take the viewpoint that extend applies a function to each element of the comonad, but this 'comonad valued function' can depend on other elements in the comonad. For (1), we simply extract the value at each component of the comonad and then gather the results, which should clearly be equivalent to doing nothing. <ref type="bibr">Law (2)</ref> states that when extending a comonad valued function over a comonad, and observing what it did to the focused element is the same as just evaluating the function on the comonad. Finally, (3) says that composing extended comonad valued functions can be done either before or after extending the second function. Compound data structures (records, containers, tuples, sum types, . . . ) are the bread and butter of real-world programs. Tools for manipulating and accessing these compound data structures are collectively called optics. In the first part of this chapter, we will follow roughly (Pickering, Gibbons, and Wu 2017).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4">References</head><p>The simplest way of accessing the components of these compounds is viewing and updating single components. Doing this naively is fairly simple. We have seen viewers for e.g. pair already:</p><formula xml:id="formula_274">:t fst --(a, b) -&gt; a fst (5, 3) --5 snd (3, 1) --1</formula><p>Writing updaters for pairs is fairly easy too:</p><formula xml:id="formula_275">fst' :: c -&gt; (a, b) -&gt; (c, b) fst' x (y, z) = (x, z)</formula><p>Looking at the type signatures, we can generalize what we mean by the accessors view and update. If s is a compound data structure, and a the type of a component in that structure, then these accessors are functions of type: We can easily generalize the update function even further, by allowing the update to take a different type b and replacing the component of type a. If we allow this, then the compound is not necessarily the same after the update, so we also have to allow for a different compound type. Let us add some syntactic sugar:</p><formula xml:id="formula_276">(^.) = flip view (2, 3)^. _ 1 --2 1200^.positive --True</formula><p>Another optical example is a prism. Prisms are to sum types as lenses are to product types. It consists of two components, match which obtains a component if it is being held by the sum type (variant), and build that creates a variant out of a component. If match fails, it returns the original variant. There is a whole zoo of optics, and we will give more examples after introducing a better framework. The problem with using the lenses and prisms as given in the this section (in concrete representations), is that they do not easily compose already with other optics of the same types, let alone when optics are mixed. In the remainder of this chapter, we will study these lenses and other examples of optics in more detail, and put them into a unifying framework which will allow us to compose them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.1">Profunctor optics</head><p>It turns out that the notion of a profunctor can be used to define and construct optics in a composable way. In category theory, these are defined as follows.</p><p>Definition 10.1. Let C and D be categories. A profunctor:</p><formula xml:id="formula_277">φ : C D, is a functor D op × C → Set.</formula><p>The underlying theory for the material we will discuss here is interesting but vast (in particular we would have to discuss monoidal categories and tensorial strengths). Therefore, we will take a pragmatic approach in this part, for once, and define most of the concepts in Haskell directly. We can define profunctors as: Let us define our two example optics, lenses and prisms, in this framework. Af- ter giving the definitions, we analyse what we gained exactly by using our new representation. First, any optic is a transformations between profunctors. Similarly, we can define Prisms in terms of transformations of coCartesian profunc- tors. In summary, with the 'concrete to profunctor' functions lensC2P and prismC2P (which, as it turns out, have inverses) we can turn any concrete lens into the (less intuitive) profunctor representation. Once they are in this representation, they compose beautifully using the standard composition operator (.) which means that it even looks like imperative code where nested accessors are usually written with dots in between.</p><p>As the final note of this section, we mention that with prisms and lenses we are only scratching the surface. There are other optics (in particular adapters and traversals) that can fit into this framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.2">Further reading</head><p>•  • Ends and co-ends.</p><p>• 'Theorems for free!'</p><p>• 'Fast and loose reasoning is morally correct' -ω-CPOs -Domain theory -Note that newtype and bottom cause issues. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Part III</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Exercises</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Parser</head><p>This exercise is based on the parser exercises of (1) and the blog post series of evaluating DSLs (spoilers in the article!) (2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Description</head><p>The goal of this exercise is to parse, and evaluate expressions such as:</p><formula xml:id="formula_278">"((x + 3) * (y + 5))" "(((x + 3) * (y + 5)) * 5)" "(x + y)" ...</formula><p>it is up to you to define precisely the rules of this language, and to enforce (or not) the use of parentheses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Preliminaries</head><p>Assume that we have the following definitions: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Implement</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>idParser :: Parser Id</head><p>A valid identifier is (in most language) a string that starts with an alpha character, followed by zero or more alphanumeric characters (remember to use the character predicates available!).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Implement</head><p>operatorParser :: Parser OperatorType 9. Combine the different parsers that you have made to make an expression parser:</p><p>expressionParser :: Parser Expression</p><p>It may be useful for debugging to implement show for Expression:</p><p>instance Show Expression where --show :: Expression -&gt; String show expr = ...</p><p>Also look at the functions ( * &gt;) and (&lt; * ) for Applicative instances, which ignore the result of a computation but keep the side effect (use this to ignore whitespace).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B) Evaluation</head><p>We define the Environment as a map that holds (integer) values for variables.</p><formula xml:id="formula_279">type Environment = Map Id Int</formula><p>Map is found in the Data.Map library. See the documentation for usage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Implement:</head><p>evaluate :: Environment -&gt; Expression -&gt; Maybe Int 2. Implement:</p><p>optimize :: Expression -&gt; Expression for example, (0 + x) can be replaced with just x, and (1 + 3) can just be evaluated to produce 4, and so on (think of other optimizations).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Implement:</head><p>partial :: Environment -&gt; Expression -&gt; Expression that replaces all the variables in the epxression with those that have values in the environment, and leaves the others intact.</p><p>4. Observe that you can implement evaluate in terms of partial followed by optimize, and do this.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Make a function:</head><p>dependencies :: Expression -&gt; <ref type="bibr">[Id]</ref> returning the variables that occur in expression. Use the Data.Set library along with the functions singleton, union, empty, toList.</p><p>6. Use dependencies to improve your error messages by implementing a func- tion</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>result :: Expression -&gt; Either String Int</head><p>That returns the result of an expression, or a string containing an error mes- sage along with the dependencies that are missing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C) Monadic parser</head><p>1. Write the Monad instance of Parser.</p><p>2. Observe that do-notation for the Parser reads very naturally:</p><formula xml:id="formula_280">threeInts :: Parser [Int] threeInts = do x &lt;-parseOneInt y &lt;-parseOneInt z &lt;-parseOneInt return [x, y, z]</formula><p>where parseOneInt = spaces * &gt; intParser</p><p>We will revisit our parser when we talk about catamorphisms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Monads</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A) IO: Hangman</head><p>Taken from (1)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Description</head><p>The goal is to make an interactive 'hangman' game in Haskell, so that:</p><p>./hangman Enter a secret word: ******* </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Preliminaries</head><p>Assume that we have the following definitions:</p><p>...</p><p>1. Implement: . . .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B) State: Simulating Risk battles</head><p>Taken from (2)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Description</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Folds</head><p>For this exercise it is good to hide the fold operations from the Prelude so that you can implement them yourself. </p><formula xml:id="formula_281">A(m, n) =        n + 1 if m = 0 A(m − 1, 1)</formula><p>if m &gt; 0 and n = 0 A(m − 1, A(m, n − 1)) if m &gt; 0 and n &gt; 0. Implement curry ack using foldn, where ack :: (Nat, Nat) -&gt; Nat. that takes a list, and an effectful predicate, and produces an effectful list con- taining only those elements satisfying the predicate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D) Finding distinct elements of a list</head><p>2. Using filtering, with State (Set a) Bool as the Applicative f, imple- ment:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Catamorphisms</head><p>In this exercise we are going to play with catamorphisms and least fixed points.</p><p>I suggest that for each part you make a new Haskell file with on the top e.g.: Use import statements to resolve dependencies. This will prevent name collisions.</p><formula xml:id="formula_282">{</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A) The Fix type class</head><p>Use the following GHC extension:</p><formula xml:id="formula_283">{-# LANGUAGE RankNTypes #-}</formula><p>As mentioned in the chapter on F -algebras, there are two (equivalent) ways to define least fixed points in Haskell, these are: Note that the answers are described in the text, if you need help.</p><formula xml:id="formula_284">data</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B) Catamorph your lists</head><p>References:</p><p>• here a is the fixed set A, and b represents X. We want to find the least fixed point, we make an alias:</p><formula xml:id="formula_285">type List a = Fix (ListF a)</formula><p>read as: the least fixed point of the endofunctor ListF a (which, as we have seen, is just the usual description of a list).</p><p>1. Write functions that make constructing a list in this least fixed point descrip- tion easier:</p><p>nil :: List a (&lt;:&gt;) :: a -&gt; List a -&gt; List a --We want the cons function to be right associative infixr 5 &lt;:&gt; 2. Make a functor instance for ListF a:</p><p>instance Functor (ListF a) where ... And observe that you only have to define local transformations, and can let cata take care of the recursive structure:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Given:</head><formula xml:id="formula_286">main = do print $ (cata sum') testCase print $ (cata sum') $ (cata square') testCase</formula><p>In essence, you are writing the ingredients of a fold, but there is no specific reference to any fold or even to any list in cata. We abuse the fact that the recursive structure is encoded in the definition of the functor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C) Catamorph your expressions</head><p>Reference:</p><p>• https://deque.blog/2017/01/20/catamorph-your-dsl-deep-dive/ Similar to lists, we can define our expression functor as:</p><formula xml:id="formula_287">data ExprF b = Cst Int | Add (b, b) type Expr = Fix ExprF</formula><p>Corresponding to the endofunctor:</p><formula xml:id="formula_288">F (X) = Int 32 + X × X.</formula><p>Here, Int 32 represents finite 32-bit integers, and Expr is the least fixed point of this functor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Write convenience functions:</head><p>cst :: Int -&gt; Expr add :: (Expr, Expr) -&gt; Expr 2. Give the functor instance for ExprF:</p><p>instance Functor ExprF where ...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Implement:</head><p>eval :: Expr -&gt; Int render :: Expr -&gt; String</p><p>Use cata and an algebra, i.e.: function = cata algebra where algebra ...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Implement:</head><p>leftUnit :: ExprF Expr -&gt; Expr rightUnit :: ExprF Expr -&gt; Expr that optimize away additions with zero.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Implement:</head><p>comp :: (ExprF Expr -&gt; Expr) -&gt; (ExprF Expr -&gt; Expr) -&gt; (ExprF Expr -&gt; Expr)</p><p>that composes two algebras with the same carrier as the initial algebra, like leftUnit and rightUnit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Implement</head><p>optimize :: Expr -&gt; Expr using comp of leftUnit and rightUnit</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D) Modularize your catamorphed expressions</head><p>Reference:</p><p>• "W. Swierstra; Data types a la carte" http://www.cs.ru.nl/~W.Swierstra/ Publications/DataTypesALaCarte.pdf</p><p>If we want to add e.g. multiplication to our little expression system defined above, we have to not only change the definition of ExprF, but also of all algebras that we defined after that. This problem has been summarized as follows:</p><p>The goal is to define a data type by cases, where one can add new cases to the data type and new functions over the data type, without recompiling existing code, and while retaining static type safety -Dubbed the 'expression problem' by Phil <ref type="bibr">Wadler in 1998</ref> and is the subject of the functional pearl referenced above.</p><p>In this exercise we will implement the ideas given in that paper. The following GHC extensions are needed:</p><formula xml:id="formula_289">{-# LANGUAGE TypeOperators #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE FlexibleInstances #-} {-# LANGUAGE FlexibleContexts #-} {-# LANGUAGE IncoherentInstances #-} First, instead of data Expr' b = Val' Int | Add' b b</formula><p>like above, we will express the different components of the coproduct in our functor independently, as in:</p><formula xml:id="formula_290">data Val e = Val Int data Add e = Add e e</formula><p>Note that Val does not depend on e, but is seen as a functor of e so that it is on the same level as the other parts of the coproduct (it is seen as a constant functor).</p><p>From the paper:</p><p>The big challenge, of course, is to combine the ValExpr and AddExpr types somehow. The key idea is to combine expressions by taking the coproduct of their signatures</p><p>Here, ValExpr and AddExpr are defined as the least fixed points of the respective functors.</p><p>We do that using: here, Val :+: Add represents the functor that we called Expr' before. Try to define a simple expression, like 2 + 3 using this system, and observe how incredibly clumsy this is. Later we will define some smart constructors.</p><formula xml:id="formula_291">data</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Implement the following instances:</head><p>instance Functor Val where ... instance Functor Add where ... instance (Functor f, Functor g) =&gt; Functor (f :+: g) where ...</p><p>3. Now we are going to define a way to evaluate expressions, we do this by defining a new typeclass, effectively saying how to evaluate an algebra for each part of the coproduct that defines our final endofunctor.  The definition of addExample illustrates how messy expressions can easily become. In this section, we remedy the situation by introducing smart constructors for addition and values.</p><p>to this end, we first define the following type class (which can look quite magical at first):</p><p>class (Functor sub, Functor sup) =&gt; sub :&lt;: sup where inj :: sub a -&gt; sup a you should read this as: sub can be used to construct a value for sup. In a way, the least fixed point for sub is a subset of the least fixed point for sup. For example, sub can be a term in sup if the latter is a coproduct. Implement: The astute Haskeller will note that there is some overlap in the second and third definitions. There is however no ambiguity as long as expressions involving :+: use no explicit parentheses. Implement also: Note that we did not have to touch any previous code! 7. We can also extend functionality beyond evaluating, again without retouching (and even without recompiling) previous code. Fill in the gaps of this pretty printer: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A Short introduction to Haskell</head><p>Here we will give an introduction to programming using Haskell. It will not be an extensive introduction, in fact it will be very brief. However, studying this section should be enough to allow you to follow along with the rest of the text even if you have no experience with Haskell. You are encouraged to look for additional material online, see also the references at the end of this section. You are assumed to have access to the Glasgow Haskell Compiler (GHC) and its interactive REPL GHCi.</p><p>To follow along, open ghci and play around with the code snippets that we provide.</p><p>We will dicuss te topics suggested by the NICTA Haskell course 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Values and assignment</head><p>A value can be assigned to a variable as follows: We note that these variables are only valid inside an expression, using a:</p><p>let <ref type="bibr">[variable = value]</ref> in <ref type="bibr">[expression]</ref> syntax, but you can also use this style of variable definition inside ghci.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Type signatures</head><p>In GHCi, you can see the type of the variable using:</p><p>:t x --x :: Char :t y --y :: Num a =&gt; a :t xs --g :: Num t =&gt; <ref type="bibr">[t]</ref> :t f --f :: Num a =&gt; a -&gt; a :t g --g :: Num a =&gt; a -&gt; a -&gt; a</p><p>Here :: means "has the type of".</p><p>The -&gt; in a type is right associative, i.e.</p><p>a -&gt; a -&gt; a == a -&gt; (a -&gt; a)</p><p>and so on. You can read this as 'for an a, we get a function from a to a'.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functions are values</head><p>Functions can be used as arguments to other (higher order) functions. E.g. Here we map a function over a list.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functions take arguments</head><p>On thing to notice about the map example, is that it although it is a function that technically takes a single argument (and produces a function from a list to a list), it can also be viewed as a function of two arguments. We will not explicitely distinguish between these two views.</p><p>We can also make anonymous 'lambda' functions:</p><formula xml:id="formula_292">map (\x -&gt; x * x) xs --[1,4,9]</formula><p>The backslash is inteded to look like a λ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functions can be composed</head><p>In Haskell there are three alternative ways of composing functions (to prevent overuse of parenthesis):</p><p>g(f 123) g $ f 123 (g . f) 123</p><p>Here, $ makes sure that all the functions on the right have been evaluated before statements on the left come in to play.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Infix operators</head><p>An operator starts with a non-alphanumeric character, e.g. +, ++, &gt;&gt;=, : are all operators, and they use infix notation by default. For example:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">+ 2 --3 [1,2] ++ [3,4] --[1,2,3,4] : [2,3] --[1,2,3]</head><p>To use them with prefix notation, we surround them with parenthesis:</p><formula xml:id="formula_293">(+) 1 2 --3</formula><p>Any function (which by default uses prefix notation) can be used infix as well using backticks:</p><p>let f x y = x * x + y * y 2 `f` 3 --13</p><p>this can make code significantly more clear when defining e.g. operations that act on multiple lists, sets, or maps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Polymorphism</head><p>We already saw the type signature of map: This is an example of a polymorphic function, it is defined for any type a and b. We refer to these 'wildcard types' as type variables. These always start with a lowercase letter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data types</head><p>To work with custom data structures, we create new data types. These are declared as follows: A data type is declared using the data keyword, and the type constructor is given a name (here DataTypeName). A data type depends on a number of type variables, here a and b. After the = sign, there are zero or more data constructors, here Zero, One, One', and Both, each depending on one or more of the type variables of the type constructor and separated by a pipe |.</p><formula xml:id="formula_294">data</formula><p>Data constructors can be used for constructing a value of the data type, or for pattern-matching on values of the data type (i.e. retrieve which constructor was used to construct the given value).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Type classes</head><p>Type classes are a way to have ad-hoc polymorphism in Haskell, while the ordinary polymorphic functions discussed before are parametric. This means that we can have different behaviour for different types. Type classes are introduced as follows:</p><p>class Eq a where (==) :: a -&gt; a -&gt; Bool</p><p>Here, we state that in order for a type a to be part of the type class Eq, we have to implement an equality function with the given signature. We can then restrict functions definitions to only work on types in this type class in the following manner:</p><p>(!=) :: Eq a =&gt; a -&gt; a -&gt; Bool x != y = not (x == y)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Monoids, Functors, Applicative and Alternative</head><p>Here we give a whirlwind tour of some interesting type classes used in Haskell, the majority of the category theory that we will discuss will explain the mathematical background and uses of these typeclasses in detail, here we summarize the resulting classes as a reference. Feel free to skip or skim them, and to come back after studying the material presented in later chapters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Monoid</head><p>Many types have one (or even multiple) monoidal structure, which means that it is possible to combine two elements to a single element, and that this way of combining has some special (but common) properties.</p><p>class Monoid m where mempty :: m mappend :: m -&gt; m -&gt; m --infix operator alias: &lt;&gt;</p><p>The implementations depend on the type m, but when implementing a Monoid instance, it is the task of the implementor to adher to the following laws:</p><p>--forall x, y, z :: m x &lt;&gt; mempty == x --identity mempty &lt;&gt; x == x (x &lt;&gt; y) &lt;&gt; z == x &lt;&gt; (y &lt;&gt; z) --associativity</p><p>For example, the following are all possible Monoid instances (given as (m, mempty, mappend)):</p><p>• (Int, 0, (+))</p><p>• (Int, 1, ( * ))</p><p>• <ref type="bibr">(Int32, minBound, max)</ref> • (Int32, maxBound, min)</p><p>• (String, "", (++))</p><p>• (Maybe, Nothing, (&lt;|)), here (&lt;|) denotes the binary function that yields the left-most non-Nothing value if anything (obviously there is also a right- most equivalent (|&gt;)). and so on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functor</head><p>A functor can take an 'ordinary' function, and apply it to a context. This con- text can be a list, the result of a computation that may have failed, a value from input/output and so on. You can also view the functor itself as the context. we see that additionally, pure is introduced as a way to put any value into an applicative context. Any applicative instance has to satisfy the following laws:</p><p>--forall v, w :: a; x, y, z :: f a; g :: a -&gt; b pure id &lt; * &gt; x = x --identity pure (.) &lt; * &gt; x &lt; * &gt; y &lt; * &gt; z = x &lt; * &gt; (y &lt; * &gt; z) --composition pure g &lt; * &gt; pure v = pure (g v) --homomorphism y &lt; * &gt; pure v = pure ($ y) &lt; * &gt; v --interchange</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Alternative</head><p>Now that we have introduced some terminology, we can introduce Alternative functors as giving an applicative context a monoidal structure. The default implementation of return is to fall back on pure from applicative. The bind operation has to satisfy the following laws: Thus bind takes a monadic value, and shoves it in a function expecting a non- monadic value (or it can bypass this function completely). A very common usage of bind is the following. which we can understand to mean that we bind the name a to whatever is inside the monadic value x, and then we can reuse it in the expressions that follow. In fact, this is so common that Haskell has convenient syntactic sugar for this pattern called do-notation. This notation is recursively desugared according to the following rules (taken from Stephen Diehl's "What I wish I knew when learning Haskell"):</p><p>Here, foldl associates to the left, and foldr associates to the right. This means:</p><p>foldl <ref type="formula">(</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Foldable</head><p>Lists are not the only data structure that can be folded. A more general signature of foldr would be:</p><formula xml:id="formula_295">foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</formula><p>where t is some foldable data structure. There is a type class, with the following core functions: Only one of these two functions has to be implemented, the one can be retrieved from the other. Here, foldMap maps each element of a foldable data structure into a monoid, and then uses the operation and identity of the monoid to fold. There is also a general fold method for each Foldable: The more 'natural' fold in Haskell is foldr, to understand why we should look at the difference between cons-lists and snoc-lists:</p><p>-http://learnyouahaskell.com/chapters</p><p>• If you are looking to do exercises, there is a guide to different courses available here:</p><p>-https://github.com/bitemyapp/learnhaskell</p><p>• A handy search engine for library functions is Hoogle:</p><p>-https://www.haskell.org/hoogle/</p><p>• Advanced topics for Haskell:</p><p>-http://dev.stephendiehl.com/hask/</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Composition: If f : a → b and g : b → c then g • f : a → c. a b c f g•f g • Composition with identity arrows: If f : x → a and g : a → x where x is arbitrary, then: id a • f = f, g • id a = g. a x ida g f • Associativity: If f : a → b, g : b → c and h : c → d then: (h • g) • f = h • (g • f ). This is the same as saying that the following diagram commutes:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 1. 2 .</head><label>2</label><figDesc>A monoid (M, ·, e) consists of: -a set M -an associative binary operation (·) : M × M → M -a unit element w.r.t (·), i.e. ∀ m e · m = m</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 1. 7 .</head><label>7</label><figDesc>An arrow f : a → b ∈ C is an isomorphism if there exists an arrow g : b → a so that: g • f = id a and f • g = id b .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 1. 8 .</head><label>8</label><figDesc>A functor F : C → D is full if for all pairs a, b ∈ C the induced function: F : Hom C (a, b) → Hom D (F a, F b), f → F f is a surjection. It is called faithful if it is an injection.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Exercise 1. 2 .</head><label>2</label><figDesc>Let F : C → D, and let f : a → b be an isomorphism in C. Show that F f : F a → F b is an isomorphism in D. Exercise 1.3. Is there a functor Z : Grp → Grp so that Z(G) is the center of G? Exercise 1.4. Let F : C → D, G : D → E be functors, define G • F : C → E and show that it is a functor.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>data</head><label></label><figDesc>Bool = True | False 1 Also called the Kleene closure of X</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Maybe a: head :: [a] -&gt; Maybe a head [] = Nothing head (x:xs) = x</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Definition 3. 2 .</head><label>2</label><figDesc>Let C be a category, and let a, b ∈ C be objects in C. A product of a and b is an object a × b ∈ C along with two arrows p 1 : a × b → a and p 2 : a × b → b (the projections) so that for all objects c ∈ C and arrows f : c → a and g : c → b there exists a unique morphism q : c → a × b that makes the following diagram commute:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Definition 3. 5 .</head><label>5</label><figDesc>Let C be a category, and let a, b ∈ C be objects in C. A coproduct of a and b is an object a + b ∈ C along with two arrows i 1 : a + b ← a and i 2 : a + b ← b (the inclusions) so that for all objects c ∈ C and arrows f : c ← a and g : c ← b there exists a unique morphism q : c ← a + b that makes the following diagram commute:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>It is clear what i 1 and i 2 are. Let V be any other set, with arrows (functions) f : A → V and g : B → V . V A + B A B q f i 1 g i 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>instance</head><label></label><figDesc>Bifunctor (,) where bimap f g (x, y) = (f x, g y) instance Bifunctor Either where bimap f _ (Left x) = Left (f x) bimap _ g (Right y) = Right (g y)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Which we can use by calling e.g. auto x = add(1, 2). The CPS version of this function looks like void add _ cps(T a, T b, F cont) { cont(a + b); }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Definition 5. 2</head><label>2</label><figDesc>(Cartesian closed category). A category C is called cartesian closed (or a CCC), if the following conditions are satisfied: 1. It has a terminal object 1. 2. For each pair a, b ∈ C there exists a product a × b. 3. For each pair a, b ∈ C there exists an object [a → b] called the exponential such that: • there exists an arrow: eval a b : [a → b] × a → b. • For any arrow f : a × b → c there is a unique arrow λf : a → [b → c] so that the following diagram commutes:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Definition 6. 1</head><label>1</label><figDesc>(Universal arrow adjunction). Let C, D be categories. Let F : C → D and G : D → C be functors. If there exists a natural transformation: η : Id C ⇒ GF, such that for all objects c ∈ C and d ∈ D, and all arrows f : c → Gd there exists a unique arrow g : F c → d such that the following diagram commutes: c GF c Gd ηc f Gg</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Definition 6. 4</head><label>4</label><figDesc>(Hom-set adjunctions). Let C, D be categories. Let F : C → D and G : D → C be functors. If there is a natural bijection: Hom D (F c, d) φ c,d −→ Hom C (c, Gd), for each c ∈ C and d ∈ D, then (F, G, {φ c,d } c∈C,d∈D ) is an adjunction. Here, the bijection should be natural in both c and d, where in D we have that for all g : d → d in D the following diagram commutes:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Equation 6 .</head><label>6</label><figDesc>2 follows directly from the functoriality of G. Definition 6.6 (Unit-counit adjunctions). Let C, D be categories. Let F : C → D and G : D → C be functors. If there are natural transformations:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>F, F : C → D and G : D → C. Assume F G and F G, with natural bijections φ c,d and φ c,d</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Definition 7. 1 .</head><label>1</label><figDesc>A monad M = (T, η, µ) over a category C, consists of an endofunc-tor T : C → C together with natural transformations:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head></head><label></label><figDesc>To print the value of any type, we precompose this function with show :: a -&gt; String.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head></head><label></label><figDesc>--attempt 1 main = print $ f (read getLine :: Int)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head></head><label></label><figDesc>above function is more commonly used with swapped arguments --and is then pronounced 'bind' (&gt;&gt;=) :: F a -&gt; (a -&gt; F b) -&gt; F b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head></head><label></label><figDesc>State data State s a = State (s -&gt; (a, s))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head></head><label></label><figDesc>Dx n Dy Du fx fy The object n is called the vertex or apex of the cone. The diagram D is called the base of the cone. A limit of a diagram D is a cone with vertex and a family of arrows (p x : → Dx) x∈A , such that for each other cone (f x : n → Dx) x∈A on D, there exists a unique map ¯ f such that for each f x the following diagram commutes: n Dx fx ¯ f px the maps p x are called the projections. The map ¯ f is often called the mediating arrow.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>-</head><label></label><figDesc>-we look at flip cata :: Fix f -&gt; (f a -&gt; a) -&gt; a --which leads us to define data Fix f = Fix { unFix :: (f a -&gt; a) -&gt; a } --now we have unFix :: Fix f -&gt; (f a -&gt; a) -&gt; a --so we can define cata = flip unFix</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head></head><label></label><figDesc>Fix f: --for a fixed point, we havèx ~= f x` --the conversion between x and f x, where x == Fix' f --can be done using Fix' and unFix' data Fix' f = Fix' { unFix' :: f (Fix' f) } --for Fix, we can define cata as: cata' :: Functor f =&gt; (a -&gt; f a) -&gt; Fix' f -&gt; a cata' alpha = alpha . fmap (cata' alpha) . unFix' --to show that we can convert between the Fix and Fix': iso :: Functor f =&gt; Fix' f -&gt; Fix f iso x = Fix (flip cata' x) invIso :: Functor f =&gt; Fix f -&gt; Fix' f invIso y = (unFix y) Fix'</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head></head><label></label><figDesc>Algebra f a = f a -&gt; a data Fix f = Fix { unFix :: f (Fix f) } cata :: Functor f =&gt; Algebra f a -&gt; Mu f -&gt; a cata a = f . fmap (cata a) . unFix</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head>Fix f.</head><label></label><figDesc>Say we have a very simple expression language, with constants and addition: data Expr' = Cst' Int | Add' (Expr', Expr') --we introduce 'holes' in the add, instead of recurring data ExprR b = Cst Int | Add (b, b) --we reobtain the original expression by finding the 'fixed point' type Expr = Fix' ExprR --we make wrappers to construct values of type Expr cst = Fix' . Cst add = Fix' . Add --we turn ExprR into a functor instance Functor ExprR where fmap _ (Cst c) = Cst c fmap f (Add (x, y)) = Add (f x, f y) We can use this in the following way: eval = cata algebra where algebra (Cst c) = c algebra (Add (x, y)) = x + y printExpr = cata algebra where algebra (Cst c) = show c algebra (Add (x, y)) = "(" ++ x ++ " + " ++ y ++ ")"</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head></head><label></label><figDesc>leftUnit :: ExprR Expr -&gt; Expr leftUnit (Add (Fix (Cst 0), e)) = e leftUnit e = Fix e rightUnit :: ExprR Expr -&gt; Expr rightUnit (Add (e, Fix (Cst 0))) = e rightUnit e = Fix e comp f g = f . unFix . g optimize = cata (leftUnit`comp`rightUnitleftUnit`comp`leftUnit`comp`rightUnit)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_32"><head></head><label></label><figDesc>extend :: Comonad w =&gt; (w a -&gt; b) -&gt; w a -&gt; w b extend f = fmap f . duplicate Of course, we can also define duplicate in terms of extend: duplicate = extend id Before we look at the Haskell versions of the comonad laws, first let us build some intuition by looking at two examples: Stream A stream is like an infinite cons-list. It is defined as: data Stream a = Cons a (Stream a) Being so similar to a list, it is clear that stream is a functor: instance Functor Stream where fmap f (Cons x xs) = Cons (f x) (fmap f xs) More interestingly, it is also a comonad: instance Comonad Stream where extract (Cons x _ ) = x duplicate (Cons x xs) = Cons (Cons x xs) (duplicate xs)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_33"><head>instance</head><label></label><figDesc>Functor (Store s) where fmap f (Store e x) = Store (f . e) x It is also a comonad, with the definition: instance Comonad (Store s) where extract (Store f x) = f x duplicate (Store f x) = Store (Store f) x</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_35"><head></head><label></label><figDesc>http://www.haskellforall.com/2013/02/you-could-have-invented-comonads. html • https://bartoszmilewski.com/2017/01/02/comonads/ • https://www.youtube.com/watch?v=F7F-BzOB670 spreadsheets (see also https://github.com/kwf/ComonadSheet) • Game of Life / diagram: https://github.com/bollu/cellularAutomata, http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is. html Chapter 10 Lenses and other optics (This brief chapter only covers the very basics of lenses and other optics, see the suggested list of literature for further reading at the end)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_37"><head></head><label></label><figDesc>Collecting these together in a single data structure defines the simplest version of a lens: data Lens a b s t = Lens { view :: s -&gt; a, update :: b -&gt; s -&gt; t } Our fst, fst' example for pairs can be put into a Lens: _ 1 = Lens fst fst' view _ 1 (3, 5) --3 update _ 1 2 (3, 5) --(2, 5) We can also make 'virtual lenses' not necessarily corresponding to concrete compo- nents, such as this positive lens: positive :: Lens Bool Bool Integer Integer positive = Lens view update where view = (&gt;= 0) update b = if b then (abs x) else (-(abs x))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_38"><head></head><label></label><figDesc>Generalizing, we can return or build a variant t different from s, and we can use a different type b to build a variant. Hence, we define a prism as: data Prism a b s t = Prism { match :: s -&gt; Either t a , build :: b -&gt; t }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_39"><head>class</head><label></label><figDesc>Profunctor p where dimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; p b c -&gt; p a d with laws (omitted here) making it a bifunctor that is contravariant in the first argument, and covariant in the second. The intuition behind p a b is that it takes values of type a to produce values of type b. The simplest example of course, is a function a -&gt; b, and indeed we can define: instance Profunctor (-&gt;) where dimap f g h = g . h . f Different classes of optics, correspond to different constraints on our functors. In this exposition, we focus on Cartesian, and coCartesian profunctors. class Profunctor p =&gt; Cartesian p where first :: p a b -&gt; p (a, c) (b, c) second :: p a b -&gt; p (c, a) (c, b) class Profunctor p =&gt; CoCartesian p where left :: p a b -&gt; p (Either a c) (Either b c) right :: p a b -&gt; p (Either c a) (Either c b) An intuition for Cartesian profunctors is that they transform an a into a b, but can carry along any contextual information of type c. Similarly, coCartesian profunctors that can turn an a into a b, can also take care of the respective sum types with c (e.g. by not transforming values the values in that component). The function arrow is both Cartesian and coCartesian. cross f g (x, y) = (f x, g y) plus f _ (Left x) = Left (f x) plus _ g (Right y) = Right (g y) instance Cartesian (-&gt;) where first h = cross h id second h = cross id h instance CoCartesian (-&gt;) where left h = plus h id right h = plus id h</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_40"><head>type</head><label></label><figDesc>Optic p a b s t = p a b -&gt; p s t A lens is an optic that works uniformly for all Cartesian profunctors. type LensP a b s t = forall p. Cartesian p =&gt; Optic p a b s t We can turn any concrete lens into this representation, using the following function: lensC2P :: Lens a b s t -&gt; LensP a b s t lensC2P (Lens v u) = dimap (fork v id) (uncurry u) . first where fork f g x = (f x, g x)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_41"><head>type</head><label></label><figDesc>PrismP a b s t = forall p. Cocartesian p =&gt; Optic p a b s prismC2P :: Prism a b s t -&gt; PrismP a b s t prismC2P (Prism m b) = diamp m (either id b) . right</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_42"><head>•</head><label></label><figDesc>Monad transformers: 'Translation of a monad along an adjunction' -https://oleksandrmanzyuk.files.wordpress.com/2012/02/ calc-mts-with-cat-th1.pdf • Proof assistants: Curry-Howard isomorphism • List of advanced topics: http://www.haskellforall.com/2014/03/ introductions-to-advanced-haskell-topics.html</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_43"><head>import</head><label></label><figDesc>Prelude hiding (foldr, foldl) A) Lists sum :: Num a =&gt; [a] -&gt; a product :: Num a =&gt; [a] -&gt; a concat :: [[a]] -&gt; [a] asString :: Show a =&gt; [a] -&gt; String B) Folds over either, maybe and binary trees 1. Implement: foldm :: (a -&gt; b -&gt; b) -&gt; b -&gt; Maybe a -&gt; b folde :: (a -&gt; b -&gt; b) -&gt; b -&gt; Either c a -&gt; b Other useful 'fold-like' functions of Maybe and Either are maybe :: (a -&gt; b) -&gt; b -&gt; Maybe a -&gt; b either :: (a -&gt; c) -&gt; (b -&gt; d) -&gt; Either a b -&gt; Either c d Implement them. They are also in the prelude. 2. Define a binary tree as: data Tree a = Node (Tree a) a (Tree a) | Leaf and implement the function foldt :: (a -&gt; b -&gt; b) -&gt; b -&gt; Tree a -&gt; b using this implement e.g. sumTree :: Num a =&gt; Tree a -&gt; a productTree :: Num a =&gt; Tree a -&gt; a C) Peano numbers Modelled after section 1.2 of 'Algebra of programming' from Bird and de Moor. Natural numbers can be represented a la Peano as: data Nat = Zero | Succ Nat square :: Nat -&gt; Nat --`last p n` returns the last natural number &lt;= n that satisfies p last :: (Nat -&gt; Bool) -&gt; Nat -&gt; Nat 4. The Ackermann function is defined as:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_44"><head></head><label></label><figDesc>From the Data61 Haskell course Recall the State monad, defined as data State s a = State { runState :: s -&gt; (a, s) }. import qualified Data.Set as S 1. Implement a function filtering :: Applicative f =&gt; (a -&gt; f Bool) -&gt; [a] -&gt; f [a]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_46"><head></head><label></label><figDesc>Fix f = Fix { unFix :: f (Fix f) } data Fix' f = Fix' { unFix' :: forall a. (f a -&gt; a) -&gt; a } 1. Write a function cata that converts an F -algebra to a catamorphism: cata :: Functor f =&gt; (f a -&gt; a) -&gt; (Fix f) -&gt; a 2. Write the isomorphisms between Fix and Fix', i.e.: iso :: Functor f =&gt; Fix f -&gt; Fix' f invIso :: Functor f =&gt; Fix' f -&gt; Fix f Hint: Fix' is also called flipCata.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_47"><head></head><label></label><figDesc>http://comonad.com/reader/2013/algebras-of-applicatives/ • https://bartoszmilewski.com/2013/06/10/understanding-f-algebras/ To define a list in the way described in Example 8.7, we write: data ListF a b = Nil | Cons a b</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_48"><head>type</head><label></label><figDesc>Algebra f a = f a -&gt; a --an example list to work with testCase :: Fix (ListF Int) testCase = 2 &lt;:&gt; 3 &lt;:&gt; 4 &lt;:&gt; nil define functions: sum' :: Algebra (ListF Int) Int square' :: Algebra (ListF Int) (List Int)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_49"><head></head><label></label><figDesc>(f :+: g) e = Inl (f e) | Inr (g e) infixr 5 :+: 1. Expressions now have the following signature: addExample :: Fix (Val :+: Add)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_50"><head>class</head><label></label><figDesc>Functor f =&gt; Eval f where evalAlg :: f Int -&gt; Int Implement: instance Eval Val where ... instance Eval Add where ... instance (Eval f, Eval g) =&gt; Eval (f :+: g) where ...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_51"><head>Finally</head><label></label><figDesc>, implement: eval :: Eval f =&gt; Fix f -&gt; Int that evaluates an expression (catamorph the algebra!) 4. From the paper:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_52"><head>instance</head><label></label><figDesc>Functor f =&gt; f :&lt;: f where ... instance (Functor f, Functor g) =&gt; f :&lt;: (f :+: g) where ... instance (Functor f, Functor g, Functor h, f :&lt;: g) =&gt; f :&lt;: (h :+: g) where ...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_53"><head></head><label></label><figDesc>inject :: (g :&lt;: f) =&gt; g (Fix f) -&gt; Fix f to perform the injection in a least fixed point representation 5. Implement smart constructors: val :: (Val :&lt;: f) =&gt; Int -&gt; Fix f (&lt;+&gt;) :: (Add :&lt;: f) =&gt; Fix f -&gt; Fix f -&gt; Fix f --make + left associative infixl 6 &lt;+&gt; Now we can construct expressions as: expression :: Fix (Add :+: Val) expression = (val 30000) &lt;+&gt; (val 200) 6. We went through all this pain to end up with what the previous exercise already allowed us to do! Let us show the advantage of this system by adding support for multiplication. Implement the gaps in: data Mul x = Mul x x instance Functor Mul where ... instance Eval Mul where ... (&lt;#&gt;) :: (Mul :&lt;: f) =&gt; Fix f -&gt; Fix f -&gt; Fix f ... --multiplication should bind tighter than addition infixl 7 &lt;#&gt; expression2 :: Fix (Val :+: Add :+: Mul) expression2 = (val 30000) &lt;+&gt; (val 200) &lt;#&gt; (val 300)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_54"><head>class</head><label></label><figDesc>Functor f =&gt; Render f where render :: Render g =&gt; f (Fix g) -&gt; String pretty :: Render f =&gt; Fix f -&gt; String ... instance Render Val where ... instance Render Add where ... instance Render Mul where ... instance (Render f, Render g) =&gt; Render (f :+: g) where ...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_56"><head>:</head><label></label><figDesc>t (2 * ) --Num a =&gt; a -&gt; a map :: (a -&gt; b) -&gt; [a] -&gt; [b] map (2 * ) xs --[2,4,6]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_58"><head></head><label></label><figDesc>DataTypeName a b = Zero | One a | One' b | Both a b</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_59"><head>class</head><label></label><figDesc>Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b --infix operator alias: &lt;$&gt; Again, each instance should satisfy certain laws. For Functor, these are: --forall f, g :: a -&gt; b fmap id == id fmap (f . g) == fmap f . fmap g For example, the List functor is implemented as: instance Functor [] where fmap = map Or the 'composition' functor: instance Functor ((-&gt;) c) where --fmap :: (a -&gt; b) -&gt; (c -&gt; a) -&gt; (c -&gt; b) fmap = (.) Applicative The most obvious use of applicative is to lift functions of multiple arguments into a context. If we have a function of multiple arguments like: g :: a -&gt; b -&gt; c Then we can't just list it into a functor (context), since we would obtain: fmap g :: f a -&gt; f (b -&gt; c) If we compose it with a function that has the signature apply :: f (b -&gt; c) -&gt; f b -&gt; f c then we obtain: apply . fmap g :: f a -&gt; f b -&gt; f c If we implement apply, then we can lift functions with an arbitrary number of arguments (by iteratively calling apply after fmap). A functor with apply is called an applicative functor, and the corresponding type class is: class Functor f =&gt; Applicative f where pure :: a -&gt; f a ap :: f (a -&gt; b) -&gt; f a -&gt; f b --infix operator alias: &lt; * &gt;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_60"><head>class</head><label></label><figDesc>Applicative f =&gt; Alternative f where empty :: f a (&lt;|&gt;) :: f a -&gt; f a -&gt; f a For example, for Maybe we can say: instance Alternative Maybe where empty = Nothing Nothing &lt;|&gt; right = right left &lt;|&gt; _ = left Or for List we have the standard concatenation monoid: instance Alternative [] where empty = [] (&lt;|&gt;) = (++) Monads A functor lets you lift functions to the functorial context. An applicative functor lets you untangle functions caught in a context (this can be e.g. an artifact of currying functions of multiple arguments) to functions in the functorial context. Another useful operation is to compose functions whose result lives inside the context, and this is done through bind &gt;&gt;= (with its flipped cousin =&lt;&lt;). To illustrate the similarities between the typeclasses Functor =&gt; Applicative =&gt; Monad:For us, the interesting part of the definition is: class Applicative m =&gt; Monad m where return :: a -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_61"><head>-</head><label></label><figDesc>-forall v :: a; x :: m a; k :: a -&gt; m b, h :: b -&gt; m c return v &gt;&gt;= k = k v x &gt;&gt;= return = x m &gt;&gt;= (\y -&gt; k y &gt;&gt;= h) = (m &gt;&gt;= k) &gt;&gt;= h</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_62"><head></head><label></label><figDesc>&gt;&gt;= (\a -&gt; {-some expression involving a -})</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_63"><head></head><label></label><figDesc>--~&gt; (1 + (2 + 3)) E.g. foldr can be implemented as: foldr f x xs = case xs of [] -&gt; x (y:ys) -&gt; y `f` (foldr f x ys)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_64"><head>class</head><label></label><figDesc>Foldable t where foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_65"><head></head><label></label><figDesc>fold :: Monoid m =&gt; t m -&gt; m --e.g. for list, if`xif`x, y, z :: m`: fold [x, y, z] --~&gt; x &lt;&gt; y &lt;&gt; z &lt;&gt; mempty</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Definition 1 .10. A natural transformation µ between two functors F, G : C → D is a family of morphisms: µ = {µ a : F a → Ga | a ∈ C}, indexed by objects in C, so that for all morphisms f : a → b the diagramcommutes. This diagram is called the naturality square. We write µ : F ⇒ G, and call µ a the component of µ at a. We can compose natural transformations, turning the set of functors from C → D into a category. Let µ : F ⇒ G and ν : G ⇒ H, then we have ν • µ : F ⇒ H defined= ν a • µ a .</head><label>1</label><figDesc></figDesc><table>F a 
Ga 

F b 
Gb 

µa 

F f 
Gf 

µ b 

by (in components): 
(ν • µ) a </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>where you perform row operations to the matrix A and simultaneously to another matrix B that is initially the identity matrix, until you reduce A to the identity matrix. The resulting matrix B, when left multiplied with the original A will perform the row operations, and hence BA = Id, or B = A −1 .Recall that we can view a group G as a category C G with a single object {•} and with arrows • → • corresponding to the elements of g. Consider the Yoneda embedding Y of this category into Fun(C op G , Set), and in particular we consider the shape of the image of • under the contravariant hom-functor h • :</head><label></label><figDesc></figDesc><table>so to perform row operations on a matrix, one can equivalently left multiply with a 
matrix obtained by applying these operations to the identity matrix. This powers 
the technique for manually inverting a matrix A, Example 4.10. Another application of Yoneda is the following classic result from 
group theory: 

Corollary 4.11 (Cayley's Theorem). Any group G is isomorphic to a subgroup of a 
permutation group. Proof. </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head>But this does not type check! First, the action getLine has type IO String, while read expects String. Then to work on the IO action, we want to lift read to take an IO String and produce an IO Int. This sounds like an fmap, and indeed</head><label>But</label><figDesc></figDesc><table>IO 
provides fmap, it is a functor! 

--attempt 2 
main = print $ f (read &lt;$&gt; getLine :: IO Int) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14" validated="false"><head>apfelmus.nfshost.com/articles/monoid-fingertree. html -https://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/</head><label></label><figDesc></figDesc><table>Elegant profunctor optics: http://www.cs.ox.ac.uk/people/jeremy. 

gibbons/publications/poptics.pdf 

• Van Laarhoven lenses: 

https://www.twanvl.nl/blog/haskell/ 
cps-functional-references 

• A great many blogposts by Bartosz Milewski, e.g.: Part II 

Advanced theory and aplications -http://dp/0521663504 

• Applicative functors: 

-Applicative ~= Monoidal. Is strong lax functor. 
-McBride, Paterson; Applicative Programming with Effects http://www. 

staff.city.ac.uk/~ross/papers/Applicative.pdf 

</table></figure>

			<note place="foot" n="1"> Actually, there are some technicalities to be worked out and the resulting category consists of &apos;small categories&apos; only.</note>

			<note place="foot" n="2"> Here we assume that this collection is a set, or that the category is so-called locally small</note>

			<note place="foot" n="2"> In C++, type constructors are referred to as concepts, and they have been a long time coming (but are not yet in the standard)</note>

			<note place="foot" n="3"> in C++ this would be done using overloading and (partial) template specialization</note>

			<note place="foot" n="1"> In C++17 there will be a standardized &apos;tagged union&apos; &apos;std::variant&apos; that more accurately models the coproduct</note>

			<note place="foot" n="1"> You can prove that faithful functors reflect commutative diagrams, by showing that it preserves non-commutative diagrams</note>

			<note place="foot" n="1"> print actually corresponds to (putStrLn. show) in Haskell</note>

			<note place="foot" n="2"> We simplify the definition slightly here, the actual class also defines a fail method which is seen as an historical flaw</note>

			<note place="foot" n="1"> What I mean here, is that the adjunction that gives rise to the State monad, also gives rise to the Store comonad.</note>

			<note place="foot">distinct :: Ord a =&gt; [a]-&gt; [a]</note>

			<note place="foot" n="1"> https://github.com/NICTA/course</note>

			<note place="foot" n="2"> A fold is also known as reduce or accumulate in other languages</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Further study</head><p>• Algebras for a monad. Eilenberg-Moore category of algebras over a monad, can also be used to show that every monad arises from an adjunction. Also have coalgebras for a comonad Lens example here:</p><p>https://bartoszmilewski.com/2017/03/14/algebras-for-monads/</p><p>• Adjunctions in Haskell. The only monad over Hask arising from an adjunc- tion that goes through Hask itself is the State monad:</p><p>You can show this using: https://en.wikipedia.org/wiki/Representable _ functor#Left _ adjoint. Witnessed by curry and uncurry. We have:</p><p>as an adjunction through Hask op . Witnessed by flip. This leads to the continuation monad, which we should talk about.  1. Write a function foldn that encapsulates this pattern:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>to see the similarity with foldr, write it as --foldn :: (() -&gt; b -&gt; b) -&gt; b -&gt; Nat -&gt; b --(the discrepency is becausè:k Nat = * `)</head><p>2. Implement the following functions using foldn  3. Using foldn, implement:</p><p>Curly braces and semicolons are usually omitted. For example, the following two snippets show the sugared and desugared version of do-notation:</p><p>Monads can be used to do all kinds of things that are otherwise relatively hard to do in a purely functional language such as Haskell:</p><p>• </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Folds</head><p>Folds 2 are an example of a recursion scheme. You could say that (generalized) folds in functional languages play a similar role to for, while, . . . statements in imperative languages. There are two main higher-order functions for folds in Haskell:</p><p>The standard Haskell lists <ref type="bibr">[a]</ref> are cons-lists, they are built from the back of the list. The reason foldr is more natural for this type of list is that the recursion structure follows the structure of the list it self:</p><p>This can be summarized by saying that a foldr deconstructs the list, it uses the shape of the construction of the list to obtain a value. The (:) operation gets replaced by the binary operation (~), while the empty list (base case) is replaced by the accumulator e.</p><p>As a special case, since the value constructors for a list are just functions, we can obtain the identity operation on lists as a fold: </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">•</forename></persName>
		</author>
		<ptr target="https://bartoszmilewski.com/2017/07/07/profunctor-optics-the-categorical-view/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">•</forename><surname>Glassery</surname></persName>
		</author>
		<ptr target="https://github.com/ekmett/lens" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Category Theory for Programmers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bartosz</forename><surname>Milewski</surname></persName>
		</author>
		<ptr target="http://www.cse.chalmers.se/edu/year/2010/course/DAT140_Types/Reynolds_typesabpara.pdf" />
		<imprint/>
	</monogr>
	<note>also</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
				<ptr target="http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes" />
		<title level="m">Recursion as initial objects in F-algebra</title>
		<imprint/>
	</monogr>
	<note>txt 11.3 Books 1. Conceptual Mathematics: A first introduction to categories</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Category Theory for the working mathematician 3. Barr and Wells, Category Theory for Computer Scientists 4. E. Riehl, Category theory in context, 5. T. Leinster, Basic Category Theory 6</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">Mac</forename><surname>Lane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Basic Category Theory 1. Implement: charParser :: Char-&gt; Parser Char 2. Implement: satisfy :: (Char-&gt; Bool</title>
		<imprint/>
	</monogr>
	<note>Parser Char satisfy predicate = ..</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">that charParser c = satisfy (== c) Useful predicates on characters are isAlpha, isAlphaNum, isDigit, isSpace, and are found in the Data</title>
		<imprint/>
	</monogr>
	<note>Char library</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
				<idno>span :: (a -&gt; Bool) -&gt; [a] -&gt;</idno>
		<title level="m">Implement: intParser :: Parser Int (possibly) useful library functions are: null :: [a]-&gt; Bool read :: Read a =&gt; String</title>
		<imprint/>
	</monogr>
<note type="report_type">&gt; a-specialize to Int</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Provide instances for Parser for the following type classes: • Functor</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">•</forename><surname>Applicative</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">&lt;|&gt;) given parsers for a and b, try to parse a; if and only if it fails</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">•</forename><surname>Alternative</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>try to parse b</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">It is also a good exercise to implement these instances for Maybe yourself</title>
	</analytic>
	<monogr>
		<title level="m">Use the corresponding instances of Maybe</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
	<note>Implement: oneOrMore :: Parser a-&gt; Parser [a] zeroOrMore :: Parser a-&gt; Parser [a</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">In fact, these functions are already implemented for you in the Alternative type class as many and some respectfully. Hint: implement both in terms of the other. For example, oneOrMore can be seen as parse one</title>
		<imprint/>
	</monogr>
	<note>Use the alternative instance of Parser. then parse zero or more</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">•</forename><surname>References</surname></persName>
		</author>
		<ptr target="https://deque.blog/2017/01/17/catamorph-your-dsl-introduction/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">•</forename><surname>References</surname></persName>
		</author>
		<idno>&gt; a all :: (a -&gt; Bool) -&gt; [a] -&gt; Bool any :: (a -&gt; Bool</idno>
		<ptr target="http://www.haskellbook.com•" />
		<title level="m">CIS194 1. Implement the functions: foldl :: (b-&gt; a-&gt; b)-&gt; b-&gt; [a]-&gt; b foldr :: (a-&gt; b-&gt; b)-&gt; b-&gt; [a]-&gt; b 2. Implement the following functions on lists using a fold: sum :: Num a =&gt;</title>
		<imprint/>
	</monogr>
	<note>Num b =&gt;. Bool concat :: [[a]]-&gt; [a] reverse :: [a]-&gt; [a] filter :: (a-&gt; Bool)-&gt; [a]-&gt; [a] map :: (a-&gt; b)-&gt; [a]-&gt; [b</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Using this notation we can write a typical recursion formula: List a = Empty | Cons a (List a)-&apos;cons&apos; List&apos; a = Empty&apos; | Snoc (List a) a-&apos;snoc&apos; References If you want to learn Haskell, the following resources are helpful as a first step: • 5 minute tutorial to get an idea</title>
		<ptr target="https://tryhaskell.org/" />
	</analytic>
	<monogr>
		<title level="m">Or mathematically, we can say that any natural number can be represented recursively as k = 0 (n + 1)</title>
		<imprint/>
	</monogr>
	<note>where n is again a natural number</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">• There is an excellent accessible Haskell book coming out soon, but it can be found already</title>
		<ptr target="http://haskellbook.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">• A cult-classic Haskell book: Bibliography Awodey</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>Category Theory</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Category Theory for Programmers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bartosz</forename><surname>Milewski</surname></persName>
		</author>
		<ptr target="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Profunctor Optics: Modular Data Accessors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Pickering</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremy</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicolas</forename><surname>Wu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Category Theory in Context</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emily</forename><surname>Riehl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>

