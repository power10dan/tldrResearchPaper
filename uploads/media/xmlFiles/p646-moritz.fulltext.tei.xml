<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/daniellin/Desktop/tldrApp/tldrResearchPaper/grobid-grobid-parent-0.4.4/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-11-09T05:16+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ExPort: Detecting and Visualizing API Usages in Large Source Code Repositories</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Evan</forename><surname>Moritz</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">The College of William and Mary</orgName>
								<address>
									<settlement>Williamsburg</settlement>
									<region>VA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mario</forename><surname>Linares-Vásquez</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">The College of William and Mary</orgName>
								<address>
									<settlement>Williamsburg</settlement>
									<region>VA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Denys</forename><surname>Poshyvanyk</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">The College of William and Mary</orgName>
								<address>
									<settlement>Williamsburg</settlement>
									<region>VA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Grechanik</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Illinois at Chicago</orgName>
								<address>
									<settlement>Chicago</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Collin</forename><surname>Mcmillan</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">University of Notre Dame</orgName>
								<orgName type="institution" key="instit2">Notre Dame</orgName>
								<address>
									<region>IN</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Malcom</forename><surname>Gethers</surname></persName>
							<email>mgethers@umbc.edu</email>
							<affiliation key="aff3">
								<orgName type="institution">University of Maryland Baltimore County</orgName>
								<address>
									<settlement>Baltimore</settlement>
									<region>MD</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">ExPort: Detecting and Visualizing API Usages in Large Source Code Repositories</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Index Terms-API usage</term>
					<term>visualization</term>
					<term>call graph</term>
					<term>code search</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper presents a technique for automatically mining and visualizing API usage examples. In contrast to previous approaches, our technique is capable of finding examples of API usage that occur across several functions in a program. This distinction is important because of a gap between what current API learning tools provide and what programmers need: current tools extract relatively small examples from single files/functions, even though programmers use APIs to build large software. The small examples are helpful in the initial stages of API learning, but leave out details that are helpful in later stages. Our technique is intended to fill this gap. It works by representing software as a Relational Topic Model, where API calls and the functions that use them are modeled as a document network. Given a starting API, our approach can recommend complex API usage examples mined from a repository of over 14 million Java methods.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Programmers build new software by using functionality provided by a multitude of pre-existing software modules such as libraries. These modules are usable because they provide public-facing Application Programming Interfaces (APIs). Building software from APIs has many benefits, including stability, testability, and common, predictable use <ref type="bibr" target="#b13">[16]</ref>.</p><p>Unfortunately, it is notoriously difficult to learn an API <ref type="bibr" target="#b10">[13]</ref>. Many barriers to API learning are well-documented. The list of problems include overly-specific <ref type="bibr" target="#b22">[25]</ref>, <ref type="bibr" target="#b15">[18]</ref> or overly- general <ref type="bibr" target="#b22">[25]</ref> explanations of API usage, lack of understanding of the relationships among code elements <ref type="bibr" target="#b10">[13]</ref>, <ref type="bibr" target="#b4">[7]</ref>, code elements with a large number of alternative uses <ref type="bibr" target="#b22">[25]</ref>, <ref type="bibr" target="#b24">[27]</ref>, <ref type="bibr" target="#b15">[18]</ref>, <ref type="bibr" target="#b14">[17]</ref>, <ref type="bibr" target="#b21">[24]</ref>, confused order of operations in extracted API examples <ref type="bibr" target="#b1">[4]</ref>, and limited details about how to reuse components relevant to a given task <ref type="bibr" target="#b11">[14]</ref>.</p><p>Recent work has helped programmers address some of these problems and learn to use individual APIs <ref type="bibr" target="#b9">[12]</ref>, <ref type="bibr" target="#b19">[22]</ref>, <ref type="bibr" target="#b22">[25]</ref>, <ref type="bibr" target="#b6">[9]</ref>, <ref type="bibr" target="#b11">[14]</ref>. These approaches focus on extracting snippets of source code that use methods provided by an API and can successfully suggest patterns of usages of these methods. However, understanding how to use an API to implement high- level functionality is not immediately obvious with examples from single files or functions.</p><p>High-level functionality is not usually implemented in single files or functions <ref type="bibr" target="#b5">[8]</ref>; it is represented by the interaction of different functions in source code that implement the func- tionality and belong to different APIs. Therefore, programmers face with a coordination barrier <ref type="bibr" target="#b10">[13]</ref>, because several low-level APIs needs to be coordinated to create high-level behaviors, and they do not know how APIs should be used. One example of a coordination barrier is when a programmer does not know how to cast the type used as output in one API to the input of another API. Another example is when several APIs complement each other, but are not actually dependent on each other. Consequently, before reuse, programmers need to identify structural dependencies between relevant elements in the code under investigation, and then to understand the roles of the elements as part of a high-level behavior that can be reused <ref type="bibr" target="#b8">[11]</ref>.</p><p>We target this problem in our interactive code search tool called ExPort. The idea behind ExPort is simple: given a task, present the programmer with a list of API methods related to that task. Once the programmer selects the API methods he or she wishes to use, present the programmer with usage examples related to the task. To be interactive, the tool presents information to the programmer visually, so that he or she may navigate the results and reason about their relationships. Previous studies <ref type="bibr" target="#b17">[20]</ref>, <ref type="bibr" target="#b18">[21]</ref>, <ref type="bibr" target="#b11">[14]</ref> have shown that presenting relationships in a visual manner greatly help the user in determining the usefulness of the results.</p><p>For the tool implementation, we generated a database from over 13,000 open source Java projects consisting of about 14 million methods. For the purposes of the prototype, we computed relationships between 3700 methods in 2 software projects: GNU Electric VLSI design system 1 , a CAD system for designing circuits; and GCJ 2 , a front-end compiler for Java projects. We used Relational Topic Modeling (RTM) <ref type="bibr" target="#b3">[6]</ref> to cal- culate these relationships and provide concrete usage examples of APIs via an interactive call-graph visualization. In addition to its primary applications, this tool can be used as a research setting to study the effectiveness of the approach and discover how developers search for APIs. ExPort is free and available for public use at http://www.cs.wm.edu/semeru/export/.</p><p>Our contribution with Export and the underlying model is three-fold: (i) we used RTM to identify similarities between API methods and provide programmers with a list of relevant methods; (ii) ExPort presents relevant API methods and API usage patterns visually in such a way that the developers can explore the relationships between API methods; and (iii) Export allows users to provide relevance (active) feedback, and passively logs user actions in order to understand users behavior when searching and browsing API usage examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. THE PROBLEM</head><p>To illustrate the problem of providing API usage examples based on API calls in single functions <ref type="bibr" target="#b0">3</ref> (as in the current approaches) instead of API calls used across several functions we discuss two API usage scenarios. In <ref type="figure" target="#fig_0">Figure 1</ref> the func- tion sendData calls two API methods: socketCreate and socketSend; in <ref type="figure">Figure II</ref> the high-level functionality implemented in the function sendData is based on the other two functions (which may be in different files or classes) that individually calls the API methods socketCreate and socketSend.</p><p>Current approaches extract sets of APIs used in relevant code examples (i.e., files, functions or code snippets) to mine frequent combinations of APIs (usage patterns). For example, if the sendData functions in Figures 1 and II are considered as relevant, after extracting the API calls in both methods, no API usage patterns are identified because API methods socketCreate and socketSend are not called by sendData in the second scenario ( <ref type="figure">Figure II)</ref>. However, in both scenarios the API methods socketCreate and socketSend are used to implement the functionality implemented by sendData.</p><p>ExPort finds API usage examples even if the usage of those APIs is in situations such as those in <ref type="figure">Figure II</ref>. For example, given the API call socketCreate, we also recommend the API call socketSend. We extract the API usage by analyzing the function invocations in existing source code, in addition to the current approach of looking at the API calls made in individual functions or files. A key feature of our approach is sensitivity to the proximity of API calls. For example, in <ref type="figure" target="#fig_0">Figure 1</ref>, the two API calls are highly related because they appear in the same function. In <ref type="figure">Figure II</ref>, the API calls are related to a lesser degree because they occur in separate functions. Programmers can better understand recom- mendations of API usage if they can also see examples of that usage. Therefore, our technique also provides these examples to programmers. These examples are sets of functions which call the recommended APIs. For example, in response to a query of the API call socketCreate, we would recommend socketSend and show (as examples) the three functions sendData, connect, and transmit from <ref type="figure">Figure II</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. OUR APPROACH</head><p>Programmers navigate software spaces (e.g., an application or a set of applications in a repository) in two ways: di- rected searching and browsing <ref type="bibr" target="#b18">[21]</ref>. The former occurs when programmers are looking for specific information, while the latter is used to explore the space and understand high-level concepts <ref type="bibr" target="#b18">[21]</ref>. Moreover, browsing is most effective when programmers follow relationships between elements in the software space <ref type="bibr" target="#b17">[20]</ref> (e.g., classes or functions in a call graph). But, when the elements are atomic units (i.e., functions or fields), the browsing process provides useful information for understanding high level concepts <ref type="bibr" target="#b16">[19]</ref>, <ref type="bibr" target="#b11">[14]</ref>.</p><p>Therefore, we considered browsing as the main feature in ExPort to help programmers when they are looking for examples implementing high-level functionality. ExPort helps to identify structural dependencies, and the role of the de- pendencies as part of a high-level functionality. It is done by computing similarities between API methods and representing the software space of relevant methods as a call graph that can be visually explored.</p><p>In general, the process follows 6 steps: 1) similarities between APIs are precomputed offline using Relational Topic Modeling; 2) the programmer inputs a query 4 to ExPort; 3) API methods related to the query are displayed to the user; 4) the user selects APIs relevant to his her task; 5) the relevant APIs are displayed in a call-graph, which shows other functions that call the APIs; 6) finally, the user selects functions from the call graph to view API usage examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Relational Topic Modeling (RTM)</head><p>Relational Topic Model is a hierarchical model that defines a comprehensive approach to modeling interconnected docu- ments, taking into account both document attributes as well as known links between documents. RTM identifies latent topics associated with documents and allows for the prediction of links between documents in large corpora based on document attributes and known relationships between the documents <ref type="bibr" target="#b3">[6]</ref>. Each document is modeled as a mixture of various topics, where a topic is a probabilistic mixture over the set of attributes (e.g., terms in a text corpus). Applications of RTM include analysis of networked data such as social networks of friends, collection of scientific papers with citations, as well as web pages and their links. RTM was previously used by <ref type="bibr">Gethers and Poshyvanyk [10]</ref> to capture conceptual relationships (degree of coupling) between classes. In ExPort we use the same motivation in <ref type="bibr" target="#b7">[10]</ref> but we consider functions as documents, and the document attributes are the API calls in the functions. Each function in a project is represented as a vector of the API calls in the function (e.g., a call to a method in a class in the Java SDK), and the calls between functions in the projects represent the links between documents. Therefore, if the model identifies a link between two functions with a high probability, we consider these functions to be similar.</p><p>RTM identifies links between documents according to topic- document distributions. Therefore, linked documents have a high probability of being associate to the same topics. Based on this property, we identified the API calls that describe similar functions by using the topic-word distribution of topics. Then, for a given API method (considered to be a starting point of the required high-level functionality), relevant methods are retrieved as the ones with high probability of being associated with the same topics. For example, given an initial method socketSend ( <ref type="figure">Figure II)</ref>, and a link identified by the model between functions connect and transmit (because both functions are called by sendData), the methods called by connect and transmit with high probability of being associated to the same topics of socketSend are retrieved as methods relevant to socketSend .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Detecting and Visualizing API Usage</head><p>ExPort provides a visual interface (GUI) to browse the space of APIs that are identified as relevant by using RTM. The GUI is composed of two views: similarity, and call-graph.</p><p>1) Similarity View: As a user enters a query, the autocom- pletion feature of the tool presents APIs that are textually related to the query as the user types. This feature allows the users to identify an API method as the starting point of the required high-level functionality. Once a query API has been chosen, the tool presents APIs related to the query in the form of a directed graph, with the original query as the root and related APIs as children <ref type="figure" target="#fig_1">(Figure 3</ref>). Further children are APIs related directly to their parent nodes (not to the original query). This helps widen the search space to account for different variations of the task. For the purposes of this prototype, a query is the initial starting API typed by the user.</p><p>For example, suppose a user wants to investigate the API JComboBox.fireActionEvent(). The user enters the query and gets as result a graph like the one in <ref type="figure" target="#fig_1">Figure 3</ref>. The query node is highlighted in yellow. The other nodes' colors indicate how many children they have in the graph, ranging from dark red (many) to pink (few) to grey (none). The user can navigate the graph to view suggested related APIs, such as the similar event handler processFocusEvent. Clicking on a node will show the method's basic information, with the ability to open a new window comparing the source code of processFocusEvent and fireActionEvent side-by- side.</p><p>2) Call-Graph View: Once a user has selected a relevant API or a set of relevant APIs, those APIs are sent to the call-graph view <ref type="figure" target="#fig_2">(Figure 4)</ref>. This displays the chain of calls in which an API is used, showing the programmer other functions that use the API. When the user clicks on a node in the call- graph, an info pane shows the actual code that implements the call, providing a concrete example of how the API is used in the code. From this the programmer can determine how to use the API in her code. The API methods selected on the Similarity view appears as red stars in the Call-graph view, and functions are represented as grey circles nodes. Orange squares correspond to other methods that are in the API (i.e., Java SDK).</p><p>From the example given in the similarity view, the user has decided to investigate how fireActionEvent is used. The call-graph for this method is shown in <ref type="figure" target="#fig_2">Figure 4</ref>.</p><p>From the method calls, the user can tell that the function contentsChanged gets called when a JComboBox re- ceives an event. The user reads that contentsChanged calls selectedItemChanged and follows the callgraph. From the code for selectedItemChanged, the user can see that the function fires an item event for the selected item, then notifies all of the JComboBox's event listeners by calling fireActionEvent. This provides a concrete example to the user on how to properly use the method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Implementation Details</head><p>This section describes the main implementation details of our tool.</p><p>1) Platform: In order to be portable and reach a large audience running on different systems, the tool is implemented as a web-based interactive GUI. This avoids the problem of changing the tool to run on different operating systems and architectures, as well as providing instant updates to all users and allowing the researcher direct access to the data. The prototype runs in an Apache web server on a Linux host.</p><p>2) Languages: Given the web-based platform, the choice of client-side language is clear: the GUI is rendered in HTML and JavaScript, communicating with the server through the standard HTTP requests (Get, Post, Cookie, Request) and Asynchronous JavaScript And XML (AJAX). The server-side architecture is written in PHP and renders pages into HTML, responds to requests, and records information.</p><p>3) Libraries: The prototype uses a graphing library to render the graphs in the GUI in JavaScript. This library is the JavaScript InfoVis Toolkit (JIT) <ref type="bibr" target="#b2">5</ref> . The prototype makes use of the jQuery 6 framework to use its advanced JavaScript capabilities. This functionality includes (but is not limited to): Document Object Model (DOM) manipulation, textbox autocomplete, UI elements, and AJAX. 4) Database: The prototype uses a pre-computed database of similarities and calls for its back end. The data is stored in a MySQL database which is linked to from the server-side architecture. The database contains tables for, among other things: individual function information, function similarities, function call graphs, and logging information. 5) WebService: The webservice implements a commonly- used webservice format, JSON. 7 The backend is provided by the server-side architecture. The same information used in the tool is provided to the public. The webservice can be called via HTTP GET parameters. <ref type="bibr" target="#b5">8</ref> The full path to the webservice implementation can be found here. <ref type="bibr" target="#b6">9</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. EXAMPLES OF DETECTING AND VISUALIZING API</head><p>USAGES WITH EXPORT To illustrate the ability of ExPort to recommend related APIs through complex relationships, we present an example of finding API usages. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Function Description</head><p>getApiInfo(apiId)</p><p>Returns information about the given apiId, such as class name, the name of file it is contained in, parameters, return value type, and more.</p><p>apiSim(apiId, threshold, cutpoint, exclude)</p><p>Returns all of the APIs similar to apiId, given the other parameters. The threshold parameter determines the similarity score which all of the APIs with equal or higher similarity scores will be included, and all of the APIs with lower similarity scores will be excluded. The cutpoint parameter determines how many total APIs to return. The exclude parameter is an array of API IDs to exclude from the query, for example when used in the breadth-first search of finding relevant APIs in the similarity view.</p><p>callee(apiId)</p><p>Returns all of the methods in the database called by apiId.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>caller(apiId)</head><p>Returns all of the methods in the database that call apiId.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>apicalls(apiId)</head><p>Returns all of the Java J2SE API methods called by apiId.</p><p>autocomplete(search) Returns the names and IDs of methods in the corpus with names containing the search term. For example, searching "save" returns entries for Properties.save() and JFileChooser.showSaveDialog().</p><p>Suppose a user wishes to investigate how menu key bindings are used in the GNU electric VSLI system, with the goal of discovering how to add his or her own key bindings to a menu item. The user enters the query keybinding and selects MenuBar.getKeyBindings() from the autocom- pletion drop-down list. The similarity view presents suggested APIs related to the query ( <ref type="figure" target="#fig_3">Figure 5</ref>). From these, the user selects two additional methods from the MenuBar class to add to the call-graph view: resetKeyBindings and resetAllKeyBindings. This produces the call-graph in <ref type="figure">Figure 6</ref>. In this view, the user can immediately see the relationship between the three methods, represented as stars. resetAllBindings calls resetBindings, which calls updateAccelerator and finally getKeyBindings.</p><p>But there is more to it than that -ExPort looks deeper into the call-graph and presents additional usage exam- ples. The four red 10 nodes in the center of the fig- ure also call updateAccelerator. Each of them de- scribes additional functionality that can be used with key bindings. Clicking on a node will display the relevant code implementing the actual functionality in the project. removeKeyBinding shows the user how a key binding can be removed from a menu item. addUserKeyBinding shows the user how a key binding can be added to a menu item. restoreSavedBindings shows the user how it is possible to restore a set of key bindings that were saved previously. Finally, addDefaultKeyBinding shows the user how the program registers its default key bindings. Each actionPerformed call leading to addDefaultKeyBinding provides the user a concrete example of how to add a menu item with a key binding. All of these examples address the user's original goal of discovering how to use key bindings in the MenuBar.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. RELATED WORK</head><p>This section describes other approaches that try to solve problems related to software search and API usage.</p><p>MAPO <ref type="bibr" target="#b23">[26]</ref>, <ref type="bibr" target="#b22">[25]</ref> is an Eclipse plugin for Mining API us- ages from Open source repositories that gathers code snippets from common online code search tools, such as Google Code Search <ref type="bibr" target="#b0">[3]</ref> and Koders <ref type="bibr">[1]</ref> (now merged with Ohloh Code). MAPO mines API usage patterns from the code snippets and clusters them based on the task they perform. A user with the MAPO Eclipse plugin installed could then select and API from their code and have MAPO return relevant usage patterns based on the code snippets. While this is similar to ExPort, it is dependent on the quality of the online search engine results. In addition, it does not present the results in a visualization of concrete usage examples.</p><p>Apatite <ref type="bibr" target="#b6">[9]</ref> is an online code search tool that creates associations between results based on how often they are used together. Apatite provides additional search options by provid- ing results at the package, class, and method granularity. The association rules are created by retrieving the first 100 results from the Yahoo! <ref type="bibr">[2]</ref> search engine. If methodB appears in the results of a search for methodA, then a link is established between them. Apatite presents its results in a column format. The textual results of each granularity are sorted and sized based on their computed relevance, with the option to view the API documentation. Apatite does not present its results graphically and does not provide concrete usage examples.</p><p>Portfolio <ref type="bibr" target="#b11">[14]</ref>, <ref type="bibr" target="#b12">[15]</ref> is a web-based code search engine that takes in a textual query as input and generates a list of suggestions based on a spreading activation network and PageRank. Portfolio then visualizes the callgraph and has the option to view source code. Portfolio primarily operates on a corpus of C/C++ projects and does not focus on API usage. Furthermore, Portfolio does not have interactive or con- figurable graphs, limiting their effectiveness. In some sense, ExPort is the spiritual successor of Portfolio, as some of the authors were involved in both projects.</p><p>PARSEweb <ref type="bibr" target="#b20">[23]</ref> assists programmers in finding code exam- ples from "source → target" queries. Given a source object type, PARSEweb will identify chains of calls that transform the object into the target object type through method calls, class constructors, and type casts. PARSEweb is implemented as an Eclipse plugin and allows the user to navigate to the relevant code functions.</p><p>Sourcerer <ref type="bibr" target="#b2">[5]</ref> is a web crawler that mirrors the functionality of popular web search engines, specialized on indexing online source code repositories. Sourcerer records several aspects of the source code artifacts it finds: source code entities (such as classes or methods), dependency relationships, keywords, and uniquely identifying information. Sourcerer recommends  <ref type="table" target="#tab_0">Table II</ref> presents a comparison of other code search tools and ExPort. As the table shows, the major web-based search tools Koders, Google Code, and Yahoo! present unstructured results, while the others offer more specialized results, fo- cusing on individual functions (and in some cases, projects). Of the code search tools listed, only ExPort, Portfolio, and PARSEweb provide real-world usage examples demonstrating how the function is used. ExPort and Portfolio are the only two tools that present results in a visualization, while the rest only offer text-based results. ExPort and Apatite are the only two tools that offer an interactive method of discovering results. Finally, ExPort is the only tool combining all of these features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSION AND FUTURE WORK</head><p>In this paper, we presented a visualization-based approach for finding relevant API usage examples. Our approach uses RTM to detect relationships between functions allowing the programmer to identify API usages across several functions. We indexed 13,000 open source Java systems containing over 14 million methods and investigated them using the visualization-based approach. Our preliminary observations indicate that visualizing methods in a call-graph is a useful tool in discovering API usages. Future work will involve performing a user study to evaluate the effectiveness of the tool compared to other code search engines and extending it to include further functionality. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Example of two API calls used in a single function. The API calls are shaded gray.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Browsing similar APIs in the similarity view.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Browsing API usage examples in the callgraph view.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. API suggestions for MenuBar.getKeyBindings() in the electric project.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>TABLE I SUMMARY OF WEBSERVICE FUNCTIONALITY.</head><label>I</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>TABLE II COMPARISON OF CODE SEARCH TOOLS. THE GRANULARITY COLUMN SPECIFIES THE LEVEL AT WHICH RESULTS ARE RETURNED (PROJECT, FUNCTION, UNSTRUCTURED). THE NEXT COLUMN SPECIFIES WHETHER THE TOOL PROVIDES USAGE EXAMPLES OF THE QUERY (YES, NO). THE RESULT COLUMN SPECIFIES THE WAY THE RESULTS ARE PRESENTED (TEXT, VISUAL). LASTLY, THE INTERACTIVE COLUMN SPECIFIES WHETHER THE RESULTS ARE INTERACTIVE (YES, NO).</head><label>II</label><figDesc></figDesc><table>Tool 
Gran. 
Example 
Result 
Interactive 
Apatite [9] 
FP 
N 
T 
Y 
ExPort 
F 
Y 
V 
Y 
Google Code [3] 
U 
N 
T 
N 
Koders [1] 
U 
N 
T 
N 
MAPO [26], [25] 
F 
N 
T 
N 
PARSEweb [23] 
F 
Y 
T 
N 
Portfolio [14], [15] 
FP 
Y 
V 
N 
Sourcerer [5] 
FP 
N 
T 
N 
Yahoo! [2] 
U 
N 
T 
N 

relevant code in response to a query based on several ranking 
heuristics. 
</table></figure>

			<note place="foot" n="1"> http://www.gnu.org/software/electric/ 2 http://www.gnu.org/software/gcc/</note>

			<note place="foot" n="3"> In this paper we use the terms function and method to distinguish between methods in software projects (functions), and methods in APIs (API methods) such as the official Sun Java SDK, Apache libraries, etc.</note>

			<note place="foot" n="4"> For our initial prototype, a query is the starting API the user is investigating. Future work will involve textual queries and return suggested APIs related to the task.</note>

			<note place="foot" n="5"> http://www.thejit.org/ 6 http://www.jquery.com/ 7 http://www.json.org/ 8 URL?function=functionname&amp;param1=value&amp;param2=.. . 9 http://www.cs.wm.edu/semeru/export/service.php</note>

			<note place="foot" n="10"> We highlighted the nodes using red color only for illustration purposes. Red nodes are not displayed on the ExPort&apos;s call-graph view</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work is supported in part by the NSF CCF-0916260, NSF CCF-1253837, NSF CCF-CCF-1016868, and NSF CA-REER CCF-1253837. Any opinions, findings, and conclusions expressed herein are the authors' and do not necessarily reflect those of the sponsors.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Google code search</title>
		<ptr target="\http://en.wikipedia.org/wiki/Google_Code_Search" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Mining api patterns as partial orders from source code: From usage scenarios to specifications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Acharya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC-FSE &apos;07</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="25" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Sourcerer: a search engine for open source code supporting structure-based search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bajracharya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ngo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Linstead</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Dou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Rigor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Baldi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lopes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Companion to the 21st ACM SIGPLAN symposium on Object-oriented programming systems, languages, and applications</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="681" to="682" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Relational topic models for document networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Blei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AISTATS&apos;09</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Asking and answering questions about unfamiliar apis: An exploratory study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Duala-Ekoko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Robillard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE&apos;12</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="266" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Do crosscutting concerns cause defects?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Eaddy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">D</forename><surname>Sherwood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">C</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Nagappan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="497" to="515" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Using association metrics to help users navigate api documentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Eisenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Stylos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Faulring</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visual Languages and Human-Centric Computing (VL/HCC), 2010 IEEE Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="23" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Using relational topic models to capture coupling among classes in object-oriented software systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gethers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Poshyvanyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSM&apos;10</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Pragmatic Software Reuse</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Holmes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Calgary</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Strathcona example recommendation tool. SIGSOFT Software Engineering Notes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Holmes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">C</forename><surname>Murphy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005-09" />
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="237" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Six learning barriers in end-user programming systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">H</forename><surname>Aung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLHCC&apos;04</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="199" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Portfolio: a search engine for finding functions and their usages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Grechanik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Poshyvanyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE&apos;11</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1043" to="1045" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Portfolio: finding relevant functions and their usage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Grechanik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Poshyvanyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE&apos;11</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="111" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Prieto-Diaz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Status report: software reusability</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="61" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A field study of API learning obstacles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Robillard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Empirical Software Engineering (EMSE)</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="703" to="732" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">What makes apis hard to learn? answers from developers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Robillard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="27" to="34" />
			<date type="published" when="2009-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Automatically inferring concern code from program investigation activities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Robillard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">C</forename><surname>Murphy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASE&apos;03</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="225" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Browsing and searching software architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Sim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">L A</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">C</forename><surname>Holt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Cox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSM&apos;99</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="381" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Navtracks: Supporting navigation in software maintenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Singer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Elves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Storey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSM&apos;05</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="325" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A web-search tool for finding api components and examples</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Stylos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on VL and HCC</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="195" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Parseweb: a programmer assistant for reusing open source code on the web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Thummalapenta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the twentysecond IEEE/ACM international conference on Automated software engineering</title>
		<meeting>the twentysecond IEEE/ACM international conference on Automated software engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="204" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Temporal analysis of api usage concepts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Uddin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Dagenais</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Robillard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE&apos;12</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="804" to="814" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Mapo: Mining api usages from open source repositories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MSR&apos;06</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="54" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Mapo: Mining and recommending api usage patterns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Mei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP&apos;09</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="318" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">What makes apis difficult to use?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zibran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Computer Science and Network Security (IJCSNS)</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="255" to="261" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>

